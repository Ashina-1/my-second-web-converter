<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AbyssAtlas - æ·±æ·µç‹ç‰ˆ</title>
    <!-- Embedded SVG favicon: Abyss King - Cool Silver/Platinum Theme -->
    <link rel="icon" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='abyss' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%231a2840;stop-opacity:1' /><stop offset='50%' style='stop-color:%232a3d5b;stop-opacity:1' /><stop offset='100%' style='stop-color:%23050404;stop-opacity:1' /></linearGradient><linearGradient id='metalGrad' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%236b8fb0;stop-opacity:0.9' /><stop offset='50%' style='stop-color:%23c4d8f0;stop-opacity:1' /><stop offset='100%' style='stop-color:%23506080;stop-opacity:0.9' /></linearGradient></defs><rect width='100' height='100' fill='url(%23abyss)'/><polygon points='50,20 65,70 50,88 35,70' fill='url(%23metalGrad)' stroke='%23c4d8f0' stroke-width='1.5'/><polygon points='50,25 60,65 50,80 40,65' fill='none' stroke='%23ffffff' stroke-width='0.8' opacity='0.5'/><path d='M20 50 Q50 40 80 50 Q50 55 20 50' stroke='%236b8fb0' stroke-width='1.5' fill='none' opacity='0.6'/><path d='M15 60 Q50 50 85 60 Q50 65 15 60' stroke='%236b8fb0' stroke-width='1' fill='none' opacity='0.4'/><circle cx='50' cy='50' r='45' fill='none' stroke='%236b8fb0' stroke-width='0.5' opacity='0.3'/></svg>">
    <!-- Font Awesome removed; icons are inline SVGs to avoid external dependency -->
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link rel="stylesheet" type="text/css" href="stylesheet-darksoul.css" />
    <script src="scripts/header.js" defer></script>
  </head>
  <body>
    <header>
      <div class="container">
        <div class="header-left">
          <a class="logo" href="index.html" aria-label="ãƒ›ãƒ¼ãƒ ">
            <svg
              width="40"
              height="28"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true"
              focusable="false"
            >
              <path
                d="M22 12c0 0-4-2-8-2s-8 2-8 2S2 14 2 18s3 4 7 4 6-2 8-4 5-4 5-6-1-2-1-2z"
                fill="none"
                stroke="currentColor"
                stroke-width="1.2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <circle cx="7" cy="12" r="1" fill="currentColor" />
            </svg>
          </a>
        </div>
        <div class="header-right">
          <a href="index.html">ãƒ›ãƒ¼ãƒ </a>
          <a href="fishing-log2.html">é‡£æœä¸€è¦§</a>
          <a href="fishing-log.html">ç™»éŒ²</a>
          <div class="nav-tools">
            <button
              class="tools-btn"
              aria-haspopup="true"
              aria-expanded="false"
            >
              ãƒ„ãƒ¼ãƒ« â–¾
            </button>
            <div class="submenu" role="menu">
              <a role="menuitem" href="pe-converter.html">PEå¤‰æ›</a>
              <a role="menuitem" href="pe(tanatoru4)-converter.html"
                >ã‚¿ãƒŠãƒˆãƒ«4</a
              >
              <a role="menuitem" href="index.html">ãã®ä»–</a>
            </div>
          </div>
          <a href="profile.html">ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«</a>
        </div>
        <button class="menu-icon" id="menuIcon" aria-label="ãƒ¡ãƒ‹ãƒ¥ãƒ¼">
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true"
            focusable="false"
          >
            <path
              d="M4 6h16M4 12h16M4 18h16"
              stroke="currentColor"
              stroke-width="1.6"
              stroke-linecap="round"
            />
          </svg>
        </button>
      </div>
      </nav>
    </header>
    <main>
      <section class="top-wrapper">
        <div class="wave top">
          <svg
            viewBox="0 0 1440 120"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill="#8b7500"
              fill-opacity="0.5"
              d="M0,80 C360,160 1080,0 1440,80 L1440,120 L0,120 Z"
            ></path>
          </svg>
        </div>
        <h2>æ·±æ·µã‚’è¨˜éŒ²ã›ã‚ˆ</h2>
        <p>
          ã“ã®ã‚µã‚¤ãƒˆã¯ã€é‡£æœè¨˜éŒ²ã¨æµ·æ³æƒ…å ±ã‚’æä¾›ã™ã‚‹ç·åˆãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã™ã€‚<br />
          é‡£æœã®è¨˜éŒ²ã€æ½®æ±ã‚°ãƒ©ãƒ•ã€å¤©æ°—æƒ…å ±ãªã©ã€é‡£ã‚Šã«å½¹ç«‹ã¤æ©Ÿèƒ½ãŒæº€è¼‰ã€‚<br />
          ã‚ãªãŸã®é‡£ã‚Šä½“é¨“ã‚’ã‚ˆã‚Šè±Šã‹ã«ã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã‚’æä¾›ã—ã¾ã™ã€‚
        </p>
        
        <!-- å¤©æ°—æƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="weather-info">
          <h3>ä»Šæ—¥ã®æµ·æ³</h3>
          
          <!-- æ½®æ±ã‚°ãƒ©ãƒ• -->
          <div class="tide-graph-container">
            <h4>æ½®æ±ã‚°ãƒ©ãƒ•</h4>
            
            <!-- 7æ—¥è¡¨ç¤ºã‚¿ãƒ– -->
            <div class="tide-tabs" id="tideTabs">
              <!-- ã‚¿ãƒ–ã¯ JavaScript ã§å‹•çš„ã«ç”Ÿæˆã•ã‚Œã¾ã™ -->
            </div>
            
            <div class="tide-graph">
              <svg id="tideChart" viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <filter id="goldGlow">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="2.5" result="coloredBlur"/>
                    <feComponentTransfer in="coloredBlur" result="blueTint">
                      <feFuncR type="linear" slope="0.8"/>
                      <feFuncG type="linear" slope="0.9"/>
                      <feFuncB type="linear" slope="1.2"/>
                    </feComponentTransfer>
                    <feMerge>
                      <feMergeNode in="blueTint"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                  <linearGradient id="goldGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#6b8fb0;stop-opacity:0.7" />
                    <stop offset="50%" style="stop-color:#c4d8f0;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#6b8fb0;stop-opacity:0.7" />
                  </linearGradient>
                </defs>
                <!-- ã‚°ãƒ©ãƒ•ã¯JavaScriptã§æç”» -->
              </svg>
              <div class="tide-legend">
                <span class="current-tide" id="currentTideStatus"></span>
              </div>
            </div>
            <!-- æº€æ½®ãƒ»å¹²æ½®æƒ…å ± -->
            <div id="tideExtremesContainer" class="tide-extremes-section" style="display: none;">
              <div class="tide-extremes-row">
                <div class="tide-extremes-column">
                  <div class="tide-extremes-header">ğŸŒŠ æº€æ½®ï¼ˆé«˜æ½®ï¼‰</div>
                  <div id="highTidesInfo" class="tide-extremes-list"></div>
                </div>
                <div class="tide-extremes-column">
                  <div class="tide-extremes-header">â¬‡ï¸ å¹²æ½®ï¼ˆä½æ½®ï¼‰</div>
                  <div id="lowTidesInfo" class="tide-extremes-list"></div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="weather-grid">
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M12 2v20M12 2l-3 3M12 2l3 3M12 22l-3-3M12 22l3-3" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M3 12h18" stroke="#d4af8c" stroke-width="2" stroke-linecap="round"/>
                  <circle cx="12" cy="12" r="8" stroke="#8b7500" stroke-width="1.5" stroke-dasharray="2 2" fill="none"/>
                </svg>
              </div>
              <div class="weather-label">ç¾åœ¨ã®æ½®ä½</div>
              <div class="weather-value" id="tideInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M2 14c2-2 4-2 6 0s4 2 6 0 4-2 6 0" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M2 18c2-2 4-2 6 0s4 2 6 0 4-2 6 0" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M2 10c2-2 4-2 6 0s4 2 6 0 4-2 6 0" stroke="#d4af8c" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/>
                </svg>
              </div>
              <div class="weather-label">æ³¢é«˜</div>
              <div class="weather-value" id="waveInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M9 6c0-2 2-4 5-4s5 2 5 4c0 2-2 4-5 4s-5-2-5-4z" stroke="#d4af8c" stroke-width="1.5" fill="#8b7500" opacity="0.3"/>
                  <path d="M12 10v8M8 14h8" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
              <div class="weather-label">æ°—æ¸©</div>
              <div class="weather-value" id="tempInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M8 6h12M6 12h14M8 18h12" stroke="#d4af8c" stroke-width="2.5" stroke-linecap="round"/>
                  <path d="M20 10l2-2l-2-2" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M20 14l2 2l-2 2" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
              <div class="weather-label">é¢¨å‘ã</div>
              <div class="weather-value" id="windDirInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M12 4c-2 0-4 1.5-4 3s2 3 4 3 4-1.5 4-3-2-3-4-3z" stroke="#d4af8c" stroke-width="1.5" fill="#8b7500" opacity="0.3"/>
                  <path d="M8 10v8c0 2 2 3 4 3s4-1 4-3v-8" stroke="#d4af8c" stroke-width="1.5" fill="none"/>
                  <path d="M12 17c1.5 0 3 0.5 3 1.5S13.5 20 12 20s-3-0.5-3-1.5S10.5 17 12 17z" fill="#d4af8c" opacity="0.8"/>
                </svg>
              </div>
              <div class="weather-label">æ°´æ¸©</div>
              <div class="weather-value" id="waterTempInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M9 6c0-2 2-4 5-4s5 2 5 4c0 2-2 4-5 4s-5-2-5-4z" stroke="#d4af8c" stroke-width="1.5" fill="#8b7500" opacity="0.3"/>
                  <path d="M14 10l-2 4-2 4" stroke="#d4af8c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M12 14l3 2M12 18l3 2" stroke="#d4af8c" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
              </div>
              <div class="weather-label">é¢¨é€Ÿ</div>
              <div class="weather-value" id="windInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <circle cx="12" cy="12" r="8" stroke="#d4af8c" stroke-width="1.5" fill="none"/>
                  <path d="M12 4v16M4 12h16" stroke="#8b7500" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
              </div>
              <div class="weather-label">æ°—åœ§</div>
              <div class="weather-value" id="pressureInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <circle cx="12" cy="12" r="10" stroke="#d4af8c" stroke-width="1.5" fill="#8b7500" opacity="0.2"/>
                  <circle cx="12" cy="12" r="7" stroke="#d4af8c" stroke-width="1.5" fill="none" opacity="0.5"/>
                </svg>
              </div>
              <div class="weather-label">é›²é‡</div>
              <div class="weather-value" id="cloudCoverInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" fill="#d4af8c" stroke="#8b7500" stroke-width="1.5"/>
                  <circle cx="17" cy="8" r="1" fill="#8b7500"/>
                  <circle cx="14" cy="6" r="0.5" fill="#8b7500"/>
                  <circle cx="19" cy="11" r="0.5" fill="#8b7500"/>
                </svg>
              </div>
              <div class="weather-label">æœˆé½¢</div>
              <div class="weather-value" id="moonInfo">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
            <div class="weather-card">
              <div class="weather-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M12 2C8 2 2 6 2 12s6 10 10 10 10-4 10-10S16 2 12 2z" fill="#d4af8c" opacity="0.3"/>
                  <path d="M7 12c1-2 4-4 8-4s6 2 6 4-3 4-6 4-6-2-8-4z" fill="#d4af8c" opacity="0.8" stroke="#8b7500" stroke-width="1"/>
                </svg>
              </div>
              <div class="weather-label">é‡£ã‚Šã‚„ã™ã•æŒ‡æ•° (AIè©•ä¾¡)</div>
              <div class="weather-value" id="aiFishability">èª­ã¿è¾¼ã¿ä¸­...</div>
            </div>
          </div>
          <div class="weather-location">
            <label for="locationSelect">åœ°ç‚¹: </label>
            <select id="locationSelect">
              <optgroup label="ç¥æˆ¸ã€œæ˜çŸ³">
                <option value="34.73,135.03">å‚æ°´</option>
                <option value="34.64,135.00">æ˜çŸ³æ¸¯</option>
                <option value="34.70,135.15">æ±Ÿå´</option>
                <option value="34.68,135.19">é­šä½</option>
                <option value="34.65,135.29">å²©å±‹ï¼ˆæ·¡è·¯å´ï¼‰</option>
              </optgroup>
              <optgroup label="å¤§é˜ªæ¹¾">
                <option value="34.34,135.40">æ³‰å—</option>
                <option value="34.36,135.37">ç”°å°»</option>
                <option value="34.38,135.32">æ³‰ä½é‡</option>
                <option value="34.25,135.47">å‹ãƒ¶å³¶</option>
              </optgroup>
              <optgroup label="å’Œæ­Œå±±ï¼ˆå²¬ã€œä¸²æœ¬ï¼‰">
                <option value="34.15,135.58">åŠ å¤ª</option>
                <option value="34.05,135.80">ç”±è‰¯</option>
                <option value="33.92,135.56">ç™½æµœ</option>
                <option value="33.73,135.44">ã™ã•ã¿</option>
                <option value="33.45,135.76">ä¸²æœ¬ï¼ˆæ½®å²¬ï¼‰</option>
              </optgroup>
              <optgroup label="ä¸‰é‡">
                <option value="34.08,136.19">å°¾é·²</option>
                <option value="33.88,136.33">ç†Šé‡</option>
                <option value="34.48,136.84">é³¥ç¾½</option>
                <option value="34.32,136.90">å¿—æ‘©ï¼ˆè‹±è™æ¹¾ï¼‰</option>
              </optgroup>
              <optgroup label="äº¬ä¸¹å¾Œã€œç¦äº•">
                <option value="35.61,134.99">é–“äººï¼ˆãŸã„ã–ï¼‰</option>
                <option value="35.73,135.41">ä¼Šæ ¹</option>
                <option value="35.47,135.22">èˆé¶´</option>
                <option value="35.52,135.78">å°æµœ</option>
              </optgroup>
            </select>
            <button id="useCurrentLocationBtn" style="padding:6px 12px; background:#0ea5e9; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.9rem;">ğŸ“ ç¾åœ¨åœ°</button>
          </div>
          <div class="cache-controls" style="margin-top:8px; display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
            <div style="font-size:0.9rem; color:#666;">
              <strong>æœ€çµ‚å–å¾—:</strong>
              <span id="weatherLastFetched">--</span>
            </div>
            <div style="font-size:0.9rem; color:#666;">
              <strong>marine:</strong>
              <span id="marineLastFetched">--</span>
            </div>
            <button id="clearCacheBtn" style="margin-left:auto; padding:6px 10px; font-size:0.9rem;">ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢</button>
          </div>
          <div class="tide-api-config" style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <label style="font-size:0.9rem; color:#666;">æ½®æ±API: Open-Meteo Marine | æ°—è±¡API: Open-Meteo (ç„¡æ–™)</label>
            <div id="tideConfigStatus" style="font-size:0.9rem; color:#666; margin-left:8px;">âœ“ API æº–å‚™å®Œäº†</div>
          </div>
        </div>

        <!-- æœ€è¿‘ã®é‡£æœã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="recent-catches">
          <h3>æœ€è¿‘ã®é‡£æœ</h3>
          <div id="recentCatchesList" class="catches-list">
            <p style="text-align: center; color: #666;">èª­ã¿è¾¼ã¿ä¸­...</p>
          </div>
          <div style="text-align: center; margin-top: 20px;">
            <a href="fishing-log2.html" class="btn twitter">ã™ã¹ã¦ã®é‡£æœã‚’è¦‹ã‚‹</a>
          </div>
        </div>

        <div class="btn-wrapper">
          <a class="btn signup" href="fishing-log.html"
            ><svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              style="vertical-align: middle; margin-right: 8px"
              aria-hidden="true"
              focusable="false"
            >
              <path
                d="M3 21v-3l11-11 3 3L6 21H3zM18 6l-3-3 3 3z"
                fill="none"
                stroke="currentColor"
                stroke-width="1.4"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            é‡£æœã‚’è¨˜éŒ²ã™ã‚‹</a
          >
          <a class="btn twitter" href="fishing-log2.html"
            ><svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              style="vertical-align: middle; margin-right: 8px"
              aria-hidden="true"
              focusable="false"
            >
              <path
                d="M3 6h18M3 12h18M3 18h18"
                fill="none"
                stroke="currentColor"
                stroke-width="1.4"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            é‡£æœãƒªã‚¹ãƒˆã‚’è¦‹ã‚‹</a
          >
        </div>
        <div class="wave bottom">
          <svg
            viewBox="0 0 1440 120"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill="#8b7500"
              fill-opacity="0.5"
              d="M0,80 C360,160 1080,0 1440,80 L1440,120 L0,120 Z"
            ></path>
          </svg>
        </div>
      </section>
    </main>
    <footer>
      <p>&copy; 2025 AbyssAtlas</p>
    </footer>
    <script>
      // æœˆé½¢è¨ˆç®—
      function getMoonPhase() {
        const now = new Date();
        const year = now.getFullYear();
        const month = now.getMonth() + 1;
        const day = now.getDate();
        
        let c = 0, e = 0, jd = 0;
        if (month < 3) {
          year--;
          month += 12;
        }
        
        c = Math.floor(year / 100);
        jd = Math.floor(365.25 * year) + Math.floor(30.6001 * (month + 1)) + day + 1720995;
        jd += 2 - c + Math.floor(c / 4);
        
        const age = ((jd - 2451550.1) / 29.530588853) % 1;
        const moonAge = age * 29.530588853;
        
        let phase = '';
        if (moonAge < 1.84566) phase = 'ğŸŒ‘ æ–°æœˆ';
        else if (moonAge < 5.53699) phase = 'ğŸŒ’ ä¸‰æ—¥æœˆ';
        else if (moonAge < 9.22831) phase = 'ğŸŒ“ ä¸Šå¼¦';
        else if (moonAge < 12.91963) phase = 'ğŸŒ” æº€ã¡ã¦ã„ã';
        else if (moonAge < 16.61096) phase = 'ğŸŒ• æº€æœˆ';
        else if (moonAge < 20.30228) phase = 'ğŸŒ– æ¬ ã‘ã¦ã„ã';
        else if (moonAge < 23.99361) phase = 'ğŸŒ— ä¸‹å¼¦';
        else if (moonAge < 27.68493) phase = 'ğŸŒ˜ ä¸‰æ—¥æœˆ';
        else phase = 'ğŸŒ‘ æ–°æœˆ';
        
        return `${phase}<br><small>æœˆé½¢ ${moonAge.toFixed(1)}</small>`;
      }

      // æœˆé½¢ã®æ•°å€¤ã ã‘ã‚’è¿”ã™ï¼ˆ0..29.53ï¼‰
      function computeMoonAge() {
        const now = new Date();
        let year = now.getFullYear();
        let month = now.getMonth() + 1;
        const day = now.getDate();
        let c = 0, jd = 0;
        if (month < 3) {
          year--;
          month += 12;
        }
        c = Math.floor(year / 100);
        jd = Math.floor(365.25 * year) + Math.floor(30.6001 * (month + 1)) + day + 1720995;
        jd += 2 - c + Math.floor(c / 4);
        const age = ((jd - 2451550.1) / 29.530588853) % 1;
        const moonAge = (age < 0 ? age + 1 : age) * 29.530588853;
        return moonAge;
      }

      // Open-Meteo Marine API ã‹ã‚‰æ³¢æƒ…å ±ã‚’å–å¾—ã™ã‚‹ï¼ˆhourly: wave_height, wave_periodï¼‰
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥(localStorage)ã‚’ä½¿ã„ TTL ã‚’è¨­ã‘ã¾ã™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 15 åˆ†ï¼‰
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ“ä½œ: å€¤ + æœ‰åŠ¹æœŸé™ + å–å¾—æ™‚åˆ»ã‚’ä¿æŒã™ã‚‹
      function setCache(key, value, ttlSeconds) {
        try {
          const record = { value: value, expires: Date.now() + ttlSeconds * 1000, fetchedAt: Date.now() };
          localStorage.setItem(key, JSON.stringify(record));
        } catch (e) {
          console.warn('setCache failed', e);
        }
      }

      // å€¤ã®ã¿ã‚’è¿”ã™å¾“æ¥äº’æ›ç‰ˆ
      function getCache(key) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return null;
          const record = JSON.parse(raw);
          if (!record || !record.expires) return null;
          if (Date.now() > record.expires) {
            localStorage.removeItem(key);
            return null;
          }
          return record.value;
        } catch (e) {
          return null;
        }
      }

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ãƒ¡ã‚¿æƒ…å ±ï¼ˆexpires, fetchedAt ãªã©ï¼‰ã‚’å–å¾—ã™ã‚‹
      function getCacheRecord(key) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return null;
          const record = JSON.parse(raw);
          if (!record || !record.expires) return null;
          if (Date.now() > record.expires) {
            localStorage.removeItem(key);
            return null;
          }
          return record;
        } catch (e) {
          return null;
        }
      }

      // æœ€çµ‚å–å¾—æ™‚åˆ»ã‚’ä¿æŒã™ã‚‹ãƒãƒƒãƒ—ï¼ˆUI æ›´æ–°ç”¨ï¼‰
      const lastFetched = { weather: {}, marine: {} };
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¿ã‚¤ãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆ7æ—¥åˆ†ï¼‰
      let globalTideData = null;

      // è¦³æ¸¬åœ°ç‚¹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆåº§æ¨™æƒ…å ±ä»˜ãï¼‰
      const tideStations = [
        { value: '9413450', name: 'æ±äº¬æ¹¾ï¼ˆæ¨ªé ˆè³€ï¼‰', lat: 35.28, lon: 139.65 },
        { value: '9414290', name: 'æ±äº¬æ¹¾ï¼ˆæ¨ªæµœï¼‰', lat: 35.46, lon: 139.64 },
        { value: '9415144', name: 'æ±äº¬æ¹¾ï¼ˆé¤¨å±±ï¼‰', lat: 34.98, lon: 139.88 },
        { value: '9414523', name: 'æˆ¿ç·åŠå³¶ï¼ˆå‹æµ¦ï¼‰', lat: 35.15, lon: 140.35 },
        { value: '9432780', name: 'ç€¬æˆ¸å†…æµ·ï¼ˆæ¾å±±ï¼‰', lat: 33.24, lon: 132.76 },
        { value: '9437540', name: 'ç´€ä¼Šæ°´é“ï¼ˆå’Œæ­Œå±±ï¼‰', lat: 34.23, lon: 135.27 },
        { value: '36.95,137.57', name: 'å¯Œå±±æ¹¾ï¼ˆå¯Œå±±ï¼‰', lat: 36.95, lon: 137.57 },
        { value: '37.27,136.63', name: 'èƒ½ç™»åŠå³¶ï¼ˆçŸ³å·ï¼‰', lat: 37.27, lon: 136.63 },
        { value: '35.68,136.06', name: 'æ•¦è³€æ¹¾ï¼ˆç¦äº•ï¼‰', lat: 35.68, lon: 136.06 },
        { value: '35.47,135.22', name: 'èˆé¶´æ¹¾ï¼ˆäº¬éƒ½ï¼‰', lat: 35.47, lon: 135.22 },
        { value: '37.90,139.23', name: 'æ–°æ½Ÿï¼ˆæ–°æ½Ÿï¼‰', lat: 37.90, lon: 139.23 }
      ];

      // 2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒãƒãƒ¼ã‚µã‚¤ãƒ³å…¬å¼ï¼‰
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // åœ°çƒã®åŠå¾„ï¼ˆkmï¼‰
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // ç¾åœ¨åœ°ã‹ã‚‰æœ€ã‚‚è¿‘ã„è¦³æ¸¬åœ°ç‚¹ã‚’è‡ªå‹•é¸æŠ
      function selectNearestStation(userLat, userLon) {
        let nearest = null;
        let minDistance = Infinity;

        tideStations.forEach(station => {
          const distance = calculateDistance(userLat, userLon, station.lat, station.lon);
          console.log(`Distance to ${station.name}: ${distance.toFixed(1)}km`);
          
          if (distance < minDistance) {
            minDistance = distance;
            nearest = station;
          }
        });

        if (nearest) {
          console.log(`Nearest station: ${nearest.name} (${minDistance.toFixed(1)}km)`);
          document.getElementById('locationSelect').value = nearest.value;
          return nearest;
        }
        return null;
      }

      // ä½ç½®æƒ…å ±ã‚’å–å¾—ã—ã¦è‡ªå‹•é¸æŠ
      function useCurrentLocation() {
        const btn = document.getElementById('useCurrentLocationBtn');
        if (!navigator.geolocation) {
          alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ±ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
          return;
        }

        btn.disabled = true;
        btn.textContent = 'ğŸ“ å–å¾—ä¸­...';

        navigator.geolocation.getCurrentPosition(
          (position) => {
            const { latitude, longitude } = position.coords;
            console.log(`Current location: ${latitude}, ${longitude}`);
            
            selectNearestStation(latitude, longitude);
            updateWeatherInfo();
            
            btn.disabled = false;
            btn.textContent = 'ğŸ“ ç¾åœ¨åœ°';
          },
          (error) => {
            console.error('Geolocation error:', error.message);
            let errorMsg = 'ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
            if (error.code === error.PERMISSION_DENIED) {
              errorMsg = 'ä½ç½®æƒ…å ±ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™';
            } else if (error.code === error.POSITION_UNAVAILABLE) {
              errorMsg = 'ä½ç½®æƒ…å ±ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“';
            }
            alert(errorMsg);
            
            btn.disabled = false;
            btn.textContent = 'ğŸ“ ç¾åœ¨åœ°';
          },
          {
            enableHighAccuracy: false,
            timeout: 10000,
            maximumAge: 300000 // 5åˆ†ä»¥å†…ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
          }
        );
      }

      function formatTimestamp(ts) {
        if (!ts) return '';
        try {
          return new Date(ts).toLocaleString('ja-JP');
        } catch (e) {
          return '';
        }
      }

      // é¢¨å‘ãï¼ˆåº¦æ•°ï¼‰ã‚’æ–‡å­—åˆ—ã«å¤‰æ›
      function getWindDirectionStr(degree) {
        if (degree === null || degree === undefined) return null;
        const dirs = ['åŒ—', 'åŒ—åŒ—æ±', 'åŒ—æ±', 'æ±åŒ—æ±', 'æ±', 'æ±å—æ±', 'å—æ±', 'å—å—æ±', 
                      'å—', 'å—å—è¥¿', 'å—è¥¿', 'è¥¿å—è¥¿', 'è¥¿', 'è¥¿åŒ—è¥¿', 'åŒ—è¥¿', 'åŒ—åŒ—è¥¿'];
        const idx = Math.round(degree / 22.5) % 16;
        return dirs[idx] || null;
      }

      // UI æ›´æ–°: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æœ€çµ‚å–å¾—æ™‚åˆ»ã‚’è¡¨ç¤º
      function refreshCacheUI(lat, lon) {
        try {
          const weatherKey = `weather:${lat}:${lon}`;
          const marineKey = `marine:${lat}:${lon}`;
          const wrec = getCacheRecord(weatherKey);
          const mrec = getCacheRecord(marineKey);
          document.getElementById('weatherLastFetched').innerText = wrec && wrec.fetchedAt ? formatTimestamp(wrec.fetchedAt) : '--';
          document.getElementById('marineLastFetched').innerText = mrec && mrec.fetchedAt ? formatTimestamp(mrec.fetchedAt) : '--';
        } catch (e) {
          // ignore
        }
      }

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤ã™ã‚‹ï¼ˆweather:, marine: ã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’å¯¾è±¡ï¼‰
      function clearCache() {
        try {
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (!k) continue;
            if (k.startsWith('weather:') || k.startsWith('marine:')) keysToRemove.push(k);
          }
          keysToRemove.forEach(k => localStorage.removeItem(k));
          // lastFetched ã‚’ã‚¯ãƒªã‚¢
          lastFetched.weather = {};
          lastFetched.marine = {};
          // UI ã‚’æ›´æ–°
          try { document.getElementById('weatherLastFetched').innerText = '--'; } catch (e) {}
          try { document.getElementById('marineLastFetched').innerText = '--'; } catch (e) {}
        } catch (e) {
          console.warn('clearCache failed', e);
        }
      }

      async function fetchMarine(lat, lon) {
        const cacheKey = `marine:${lat}:${lon}`;
        const TTL_SECONDS = 15 * 60; // 15åˆ†

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°ãã‚Œã‚’è¿”ã™
        const cached = getCacheRecord(cacheKey);
        if (cached) {
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: æœ€çµ‚å–å¾—æ™‚åˆ»ã‚’è¨˜éŒ²ã—ã¦è¿”ã™
          lastFetched.marine[cacheKey] = cached.fetchedAt;
          try { document.getElementById('marineLastFetched').innerText = formatTimestamp(cached.fetchedAt); } catch (e) {}
          return cached.value;
        }

        const tz = 'Asia/Tokyo';
        const now = new Date();
        // start: ä»Šã®1æ™‚é–“å‰ã€end: ä»Šã‹ã‚‰24æ™‚é–“å¾Œï¼ˆISO without millisecondsï¼‰
        const start = new Date(now.getTime() - 1 * 60 * 60 * 1000).toISOString().slice(0, 19);
        const end = new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString().slice(0, 19);
        const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,wave_period&start=${start}&end=${end}&timezone=${tz}`;

        const res = await fetch(url);
        if (!res.ok) throw new Error('marine API error: ' + res.status);
        const json = await res.json();

        // æˆåŠŸã—ãŸã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
        try {
          setCache(cacheKey, json, TTL_SECONDS);
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜å¾Œã«ãƒ¡ã‚¿æƒ…å ±ã‚’èª­ã¿å–ã‚Šã€æœ€çµ‚å–å¾—æ™‚åˆ»ã‚’åæ˜ 
          const rec = getCacheRecord(cacheKey);
          if (rec && rec.fetchedAt) {
            lastFetched.marine[cacheKey] = rec.fetchedAt;
            try { document.getElementById('marineLastFetched').innerText = formatTimestamp(rec.fetchedAt); } catch (e) {}
          }
        } catch (e) {
          console.warn('failed to cache marine response', e);
        }

        return json;
      }

      // æ½®æ±ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆï¼ˆæ­£å¼¦æ³¢ã§7æ—¥åˆ†ï¼‰
      function generateTideData() {
        const data = [];
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const currentTime = currentHour + currentMinute / 60;
        
        // 7æ—¥åˆ†ï¼ˆ168æ™‚é–“ï¼‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼ˆ0.5æ™‚é–“ã”ã¨ï¼‰
        for (let h = 0; h <= 168; h += 0.5) {
          // æ­£å¼¦æ³¢ã§æ½®ä½ã‚’è¨ˆç®—ï¼ˆæŒ¯å¹…100cmã€å‘¨æœŸ12.42æ™‚é–“ï¼‰
          const tideHeight = 100 + 80 * Math.sin((h / 12.42) * 2 * Math.PI - Math.PI / 2);
          data.push({ hour: h, height: tideHeight });
        }
        
        // referenceTime ã¨ referenceHourOfDay ã‚’è¿½åŠ 
        const refDate = new Date();
        refDate.setHours(0, 0, 0, 0); // ä»Šæ—¥ã®00:00
        const referenceTime = refDate.getTime();
        const referenceHourOfDay = now.getHours() + now.getMinutes() / 60;
        
        return { data, currentTime, referenceTime, referenceHourOfDay };
      }

      // æº€æ½®ãƒ»å¹²æ½®ã‚’æ¤œå‡ºã™ã‚‹ï¼ˆ3ç‚¹ç§»å‹•å¹³å‡ã§å¹³æ»‘åŒ–ã—ã¦ã‹ã‚‰æ¥µå€¤ã‚’æ¤œå‡ºï¼‰
      // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå¢ƒç•Œã§ã®æ¥µå€¤ã‚‚æ¤œå‡ºã§ãã‚‹ã‚ˆã†ã€å…ˆé ­ã¨æœ«å°¾ã‚‚åŒ…æ‹¬çš„ã«å‡¦ç†
      function findTideExtremes(data) {
        if (!data || data.length < 3) return { highTides: [], lowTides: [] };
        
        // 3ç‚¹ç§»å‹•å¹³å‡ã§å¹³æ»‘åŒ–
        const smoothed = [];
        for (let i = 1; i < data.length - 1; i++) {
          const avg = (data[i - 1].height + data[i].height + data[i + 1].height) / 3;
          smoothed.push({ 
            hour: data[i].hour, 
            height: avg, 
            originalIndex: i 
          });
        }
        
        const highTides = [];
        const lowTides = [];
        
        // æ¥µå¤§å€¤ï¼ˆæº€æ½®ï¼‰ã¨æ¥µå°å€¤ï¼ˆå¹²æ½®ï¼‰ã‚’æ¤œå‡º
        for (let i = 1; i < smoothed.length - 1; i++) {
          const prev = smoothed[i - 1].height;
          const curr = smoothed[i].height;
          const next = smoothed[i + 1].height;
          
          // æ¥µå¤§å€¤: å‰å¾Œã‚ˆã‚Šé«˜ã„
          if (curr > prev && curr > next) {
            const originalData = data[smoothed[i].originalIndex];
            highTides.push({
              hour: originalData.hour,
              height: originalData.height,
              timeStr: formatTideTime(originalData.hour)
            });
          }
          // æ¥µå°å€¤: å‰å¾Œã‚ˆã‚Šä½ã„
          else if (curr < prev && curr < next) {
            const originalData = data[smoothed[i].originalIndex];
            lowTides.push({
              hour: originalData.hour,
              height: originalData.height,
              timeStr: formatTideTime(originalData.hour)
            });
          }
        }
        
        // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå¢ƒç•Œã§ã®æ¥µå€¤ã‚‚æ¤œå‡ºï¼ˆæœ€åˆã¨æœ€å¾Œã®ç‚¹ã®å‘¨è¾ºï¼‰
        // æœ€åˆã®ç‚¹ãŒæ¥µå€¤ã®å¯èƒ½æ€§
        if (data.length >= 2) {
          if (data[0].height > data[1].height) {
            highTides.unshift({
              hour: data[0].hour,
              height: data[0].height,
              timeStr: formatTideTime(data[0].hour)
            });
          } else if (data[0].height < data[1].height) {
            lowTides.unshift({
              hour: data[0].hour,
              height: data[0].height,
              timeStr: formatTideTime(data[0].hour)
            });
          }
        }
        
        // æœ€å¾Œã®ç‚¹ãŒæ¥µå€¤ã®å¯èƒ½æ€§
        if (data.length >= 2) {
          const lastIdx = data.length - 1;
          if (data[lastIdx].height > data[lastIdx - 1].height) {
            highTides.push({
              hour: data[lastIdx].hour,
              height: data[lastIdx].height,
              timeStr: formatTideTime(data[lastIdx].hour)
            });
          } else if (data[lastIdx].height < data[lastIdx - 1].height) {
            lowTides.push({
              hour: data[lastIdx].hour,
              height: data[lastIdx].height,
              timeStr: formatTideTime(data[lastIdx].hour)
            });
          }
        }
        
        console.log('findTideExtremes - highTides:', highTides.length, 'lowTides:', lowTides.length);
        if (highTides.length > 0) console.log('  Sample highTide:', highTides[0]);
        if (lowTides.length > 0) console.log('  Sample lowTide:', lowTides[0]);
        
        return { highTides, lowTides };
      }
      
      // ç›¸å¯¾æ™‚åˆ»ã‚’å®Ÿéš›ã®æ™‚åˆ»æ–‡å­—åˆ—ã«å¤‰æ›ï¼ˆAM/PMä»˜ãï¼‰
      function formatTideTime(hour) {
        const h = Math.floor(hour);
        const m = Math.round((hour % 1) * 60);
        return `${h}æ™‚${m}åˆ†`;
      }

      // æº€æ½®ãƒ»å¹²æ½®æƒ…å ±ã‚’UIã«è¡¨ç¤ºï¼ˆæŒ‡å®šæ—¥ã®ã¿ã€æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã¾ã§ã®æ™‚é–“ä»˜ãï¼‰
      function displayTideExtremes(extremes, referenceHourOfDay, isMeters, dayOffset = 0, currentTime = null) {
        const container = document.getElementById('tideExtremesContainer');
        const highTidesInfo = document.getElementById('highTidesInfo');
        const lowTidesInfo = document.getElementById('lowTidesInfo');
        
        console.log('displayTideExtremes called - dayOffset:', dayOffset, 'referenceHourOfDay:', referenceHourOfDay, 'isMeters:', isMeters);
        console.log('  extremes.highTides:', extremes.highTides.length, 'extremes.lowTides:', extremes.lowTides.length);
        
        if (!container || !highTidesInfo || !lowTidesInfo) {
          console.log('  Missing container elements');
          return;
        }
        
        // æ¥µå€¤ãŒè¦‹ã¤ã‹ã£ãŸã‹ãƒã‚§ãƒƒã‚¯
        if (extremes.highTides.length === 0 && extremes.lowTides.length === 0) {
          console.log('  No extremes found, hiding container');
          container.style.display = 'none';
          return;
        }
        
        // ã‚¯ãƒªã‚¢
        highTidesInfo.innerHTML = '';
        lowTidesInfo.innerHTML = '';
        
        // æŒ‡å®šæ—¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆdayOffsetæ—¥ç›®ã®0-24æ™‚ï¼‰
        // ãŸã ã—ã€å¢ƒç•Œä»˜è¿‘ã®æ¥µå€¤ã‚’ã‚­ãƒ£ãƒƒãƒã™ã‚‹ãŸã‚ã€å‰å¾Œ12æ™‚é–“ã‚‚å«ã‚ã‚‹
        const dayStartHour = dayOffset * 24;
        const dayEndHour = (dayOffset + 1) * 24;
        const filterStartHour = dayStartHour - 12;  // å‰æ—¥ã®12æ™‚ä»¥é™ã‚‚å¯¾è±¡
        const filterEndHour = dayEndHour + 12;      // ç¿Œæ—¥ã®12æ™‚ã¾ã§ã‚‚å¯¾è±¡
        
        console.log('  Filtering for display range [' + dayStartHour + ',' + dayEndHour + '), detection range [' + filterStartHour + ',' + filterEndHour + ')');
        
        // æº€æ½®æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆæŒ‡å®šæ—¥ã®ã¿ï¼‰
        let highCount = 0;
        extremes.highTides.forEach(tide => {
          console.log('    Checking highTide hour:', tide.hour, 'in detection range [' + filterStartHour + ',' + filterEndHour + ')?', tide.hour >= filterStartHour && tide.hour < filterEndHour, '/ display range [' + dayStartHour + ',' + dayEndHour + ')?', tide.hour >= dayStartHour && tide.hour < dayEndHour);
          // æ¤œå‡ºç¯„å›²ã«ã¯å«ã¾ã‚Œã‚‹ãŒã€è¡¨ç¤ºç¯„å›²ï¼ˆæŒ‡å®šæ—¥0-24æ™‚ï¼‰ã«ã®ã¿è¡¨ç¤º
          // dayOffset=0ã®å ´åˆã€hour: 0-24 (inclusive end) ã‚’è¨±å¯ã—ã¦ç¿Œæ—¥ã«è¿‘ã„æ¥µå€¤ã‚‚ã‚­ãƒ£ãƒƒãƒ
          const isWithinDay = (tide.hour >= dayStartHour && tide.hour <= dayEndHour);
          
          if (tide.hour >= filterStartHour && tide.hour < filterEndHour && isWithinDay) {
            highCount++;
            const relativeHour = tide.hour - dayStartHour;
            const actualHour = (referenceHourOfDay + relativeHour) % 24;
            const displayHour = Math.floor(actualHour);
            const displayMin = Math.round((actualHour % 1) * 60);
            const timeStr = `${displayHour}æ™‚${displayMin}åˆ†`;
            const heightStr = isMeters 
              ? (tide.height * 100).toFixed(0) + ' cm'
              : Math.round(tide.height) + ' cm';
            
            // æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã¾ã§ã®æ™‚é–“ã‚’è¨ˆç®—ï¼ˆdayOffset=0 ã®å ´åˆã®ã¿ï¼‰
            let timeUntilStr = '';
            if (dayOffset === 0 && currentTime !== null && tide.hour >= currentTime) {
              const timeUntil = tide.hour - currentTime;
              const hours = Math.floor(timeUntil);
              const minutes = Math.round((timeUntil % 1) * 60);
              if (hours >= 0 && minutes >= 0) {
                timeUntilStr = `ï¼ˆã‚ã¨${hours}æ™‚é–“${minutes}åˆ†ï¼‰`;
              }
            }
            
            const item = document.createElement('div');
            item.className = 'tide-extremes-item';
            item.innerHTML = `<span class="tide-time">${timeStr}${timeUntilStr}</span><span class="tide-height">${heightStr}</span>`;
            highTidesInfo.appendChild(item);
          }
        });
        
        // å¹²æ½®æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆæŒ‡å®šæ—¥ã®ã¿ï¼‰
        let lowCount = 0;
        extremes.lowTides.forEach(tide => {
          console.log('    Checking lowTide hour:', tide.hour, 'in detection range [' + filterStartHour + ',' + filterEndHour + ')?', tide.hour >= filterStartHour && tide.hour < filterEndHour, '/ display range [' + dayStartHour + ',' + dayEndHour + ')?', tide.hour >= dayStartHour && tide.hour < dayEndHour);
          // æ¤œå‡ºç¯„å›²ã«ã¯å«ã¾ã‚Œã‚‹ãŒã€è¡¨ç¤ºç¯„å›²ï¼ˆæŒ‡å®šæ—¥0-24æ™‚ï¼‰ã«ã®ã¿è¡¨ç¤º
          // hour: 0-24 (inclusive end) ã‚’è¨±å¯ã—ã¦ç¿Œæ—¥ã«è¿‘ã„æ¥µå€¤ã‚‚ã‚­ãƒ£ãƒƒãƒ
          const isWithinDay = (tide.hour >= dayStartHour && tide.hour <= dayEndHour);
          
          if (tide.hour >= filterStartHour && tide.hour < filterEndHour && isWithinDay) {
            lowCount++;
            const relativeHour = tide.hour - dayStartHour;
            const actualHour = (referenceHourOfDay + relativeHour) % 24;
            const displayHour = Math.floor(actualHour);
            const displayMin = Math.round((actualHour % 1) * 60);
            const timeStr = `${displayHour}æ™‚${displayMin}åˆ†`;
            const heightStr = isMeters 
              ? (tide.height * 100).toFixed(0) + ' cm'
              : Math.round(tide.height) + ' cm';
            
            // æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã¾ã§ã®æ™‚é–“ã‚’è¨ˆç®—ï¼ˆdayOffset=0 ã®å ´åˆã®ã¿ï¼‰
            let timeUntilStr = '';
            if (dayOffset === 0 && currentTime !== null && tide.hour >= currentTime) {
              const timeUntil = tide.hour - currentTime;
              const hours = Math.floor(timeUntil);
              const minutes = Math.round((timeUntil % 1) * 60);
              if (hours >= 0 && minutes >= 0) {
                timeUntilStr = `ï¼ˆã‚ã¨${hours}æ™‚é–“${minutes}åˆ†ï¼‰`;
              }
            }
            
            const item = document.createElement('div');
            item.className = 'tide-extremes-item';
            item.innerHTML = `<span class="tide-time">${timeStr}${timeUntilStr}</span><span class="tide-height">${heightStr}</span>`;
            lowTidesInfo.appendChild(item);
          }
        });
        
        console.log('  Displayed: ' + highCount + ' high tides, ' + lowCount + ' low tides');
        
        // ã‚³ãƒ³ãƒ†ãƒŠã‚’è¡¨ç¤º
        if (extremes.highTides.length > 0 || extremes.lowTides.length > 0) {
          container.style.display = 'block';
        }
      }

      // SVGã§æ½®æ±ã‚°ãƒ©ãƒ•ã‚’æç”»
      // å¼•æ•°ã« tideObj ã‚’å—ã‘å–ã‚‹ã€‚dayOffsetã§è¡¨ç¤ºæ—¥ã‚’æŒ‡å®šï¼ˆ0=ä»Šæ—¥ï¼‰
      function drawTideChart(tideObj, dayOffset = 0) {
        try {
          const td = tideObj || generateTideData();
          const { data, currentTime, referenceTime, referenceHourOfDay } = td;
          
          console.log('drawTideChart called:', {
            dayOffset,
            totalDataPoints: data.length,
            dataHourRange: data.length > 0 ? `${Math.min(...data.map(d => d.hour)).toFixed(1)} to ${Math.max(...data.map(d => d.hour)).toFixed(1)}` : 'N/A'
          });
          
          const svg = document.getElementById('tideChart');
          if (!svg) {
            console.error('SVG element #tideChart not found');
            return;
          }
          // ãƒ‡ãƒ•ã‚¹ã¨æ—¢å­˜ã®è¦ç´ ã‚’ä¿æŒã—ãªãŒã‚‰ã€ã‚°ãƒ©ãƒ•è¦ç´ ã ã‘ã‚’ã‚¯ãƒªã‚¢
          // ã™ã¹ã¦ã®å­è¦ç´ ã‚’å‰Šé™¤ã—ã€å¾Œã§defsã‚’å¾©å…ƒ
          const origDefs = svg.querySelector('defs');
          const defsClone = origDefs ? origDefs.cloneNode(true) : null;
          svg.innerHTML = '';
          if (defsClone) svg.appendChild(defsClone);
          
          // æŒ‡å®šæ—¥ã®24æ™‚é–“ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
          const dayStartHour = dayOffset * 24;
          const dayEndHour = (dayOffset + 1) * 24;
          const dayData = data.filter(d => d.hour >= dayStartHour && d.hour < dayEndHour)
            .map(d => ({ hour: d.hour - dayStartHour, height: d.height })); // ç›¸å¯¾æ™‚åˆ»ã«å¤‰æ›
          
          console.log('Filtered data for day', dayOffset, ':', {
            dayStartHour,
            dayEndHour,
            filteredDataPoints: dayData.length,
            firstPoint: dayData.length > 0 ? dayData[0] : 'N/A',
            lastPoint: dayData.length > 0 ? dayData[dayData.length - 1] : 'N/A'
          });
          
          if (dayData.length === 0) {
            console.warn('No data found for day', dayOffset, '- all data points:', data.map(d => ({ hour: d.hour.toFixed(1), height: d.height.toFixed(0) })).slice(0, 10));
            svg.innerHTML = '<text x="300" y="100" text-anchor="middle" fill="#999">ãƒ‡ãƒ¼ã‚¿ãªã—</text>';
            return;
          }
        
        const width = 600;
        const height = 200;
        const padding = { top: 20, right: 30, bottom: 30, left: 60 };
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;
        
        // ãƒ‡ãƒ¼ã‚¿ã®é«˜ã•ã®ç¯„å›²ã‚’å–å¾—ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ã®å ´åˆã‚’æƒ³å®šï¼‰
        const heights = dayData.map(d => d.height);
        const minHeight = Math.min(...heights);
        const maxHeight = Math.max(...heights);
        const heightRange = maxHeight - minHeight;
        
        // é«˜ã•ã®å˜ä½ã‚’åˆ¤å®šï¼ˆç¯„å›²ãŒ10æœªæº€ãªã‚‰ãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ã¨åˆ¤å®šï¼‰
        const isMeters = heightRange < 10; // ç¯„å›²ãŒ10æœªæº€ãªã‚‰ãƒ¡ãƒ¼ãƒˆãƒ«
        const displayUnit = isMeters ? 'm' : 'cm';
        const displayScale = isMeters ? 1 : 1; // ãã®ã¾ã¾è¡¨ç¤º
        
        // èƒŒæ™¯
        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bg.setAttribute('width', width);
        bg.setAttribute('height', height);
        bg.setAttribute('fill', '#050404');
        svg.appendChild(bg);
        
        // æ·±æ·µã®å¾®ã‹ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯ï¼ˆå†·ãŸã„é’ç™½ã„è¼ãï¼‰
        const defs = svg.querySelector('defs');
        if (!defs) {
          const newDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          svg.insertBefore(newDefs, svg.firstChild);
        }
        
        const radialGrad = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        radialGrad.setAttribute('id', 'abyssGlow');
        radialGrad.setAttribute('cx', '50%');
        radialGrad.setAttribute('cy', '50%');
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('style', 'stop-color:#1a2840;stop-opacity:0.2');
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('style', 'stop-color:#050404;stop-opacity:1');
        radialGrad.appendChild(stop1);
        radialGrad.appendChild(stop2);
        
        const defsElement = svg.querySelector('defs');
        if (defsElement) defsElement.appendChild(radialGrad);
        
        const gradBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        gradBg.setAttribute('width', width);
        gradBg.setAttribute('height', height);
        gradBg.setAttribute('fill', 'url(#abyssGlow)');
        svg.appendChild(gradBg);
        
        // ã‚°ãƒªãƒƒãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆæ¨ªï¼‰
        for (let i = 0; i <= 4; i++) {
          const y = padding.top + (chartHeight / 4) * i;
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', padding.left);
          line.setAttribute('y1', y);
          line.setAttribute('x2', width - padding.right);
          line.setAttribute('y2', y);
          line.setAttribute('stroke', '#2a3d5b');
          line.setAttribute('stroke-width', '1');
          line.setAttribute('stroke-dasharray', '2,2');
          svg.appendChild(line);
        }
        
        // Yè»¸ãƒ©ãƒ™ãƒ«ï¼ˆcm å˜ä½ã§è¡¨ç¤ºï¼‰
        for (let i = 0; i <= 4; i++) {
          const y = padding.top + (chartHeight / 4) * i;
          const heightValue = maxHeight - (heightRange / 4) * i;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', padding.left - 10);
          text.setAttribute('y', y + 5);
          text.setAttribute('text-anchor', 'end');
          text.setAttribute('fill', '#a89560');
          text.setAttribute('font-size', '12');
          // ãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ã®å ´åˆã¯ cm ã«å¤‰æ›ã—ã¦è¡¨ç¤º
          const displayValue = isMeters ? Math.round(heightValue * 100) : Math.round(heightValue);
          text.textContent = displayValue + ' cm';
          svg.appendChild(text);
        }
        
        // Xè»¸ãƒ©ãƒ™ãƒ«ï¼ˆæ™‚åˆ»ï¼‰ - å®Ÿéš›ã®æ™‚åˆ»ã‚’è¡¨ç¤º
        const refHourOfDay = referenceHourOfDay || 0;
        for (let h = 0; h <= 24; h += 3) {
          const x = padding.left + (h / 24) * chartWidth;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', x);
          text.setAttribute('y', height - 10);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('fill', '#a89560');
          text.setAttribute('font-size', '12');
          // å®Ÿéš›ã®æ™‚åˆ»ã‚’è¨ˆç®—ï¼ˆdayOffsetã‚’è€ƒæ…®ï¼‰
          const totalHour = refHourOfDay + dayOffset * 24 + h;
          const actualHour = Math.floor(totalHour % 24);
          text.textContent = actualHour + 'æ™‚';
          svg.appendChild(text);
        }
        
        // æ½®ä½ç·šã‚’æç”»ï¼ˆå‹•çš„ã‚¹ã‚±ãƒ¼ãƒ«ã€æŒ‡å®šæ—¥ã®24æ™‚é–“ï¼‰
        let pathData = '';
        dayData.forEach((point, index) => {
          const displayHour = Math.max(0, point.hour);
          const x = padding.left + (displayHour / 24) * chartWidth;
          // heightRange ã§ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
          const normalizedHeight = (point.height - minHeight) / heightRange;
          const y = padding.top + chartHeight - (normalizedHeight * chartHeight);
          
          if (pathData === '') {
            pathData = 'M' + x + ',' + y + ' ';
          } else {
            pathData += 'L' + x + ',' + y + ' ';
          }
        });
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('stroke', 'url(#goldGradient)');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('filter', 'url(#goldGlow)');
        svg.appendChild(path);
        
        // ç¾åœ¨æ™‚åˆ»ã®ãƒãƒ¼ã‚«ãƒ¼ï¼ˆä»Šæ—¥ã®å ´åˆã®ã¿ï¼‰
        if (dayOffset === 0) {
          // dayOffset=0ã®å ´åˆã€è¤‡æ•°æ—¥ãƒ‡ãƒ¼ã‚¿å†…ã§ã®ç¾åœ¨æ™‚åˆ»ã®çµ¶å¯¾ä½ç½®ã‚’è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
          // referenceTimeï¼ˆãƒ‡ãƒ¼ã‚¿é–‹å§‹æ™‚åˆ»ï¼‰ã‹ã‚‰ç¾åœ¨æ™‚åˆ»ã¾ã§ã®ãƒŸãƒªç§’å·®ã‚’è¨ˆç®—
          const nowMs = Date.now();
          const totalHoursSinceReference = (nowMs - referenceTime) / (1000 * 60 * 60);
          
          // ã‚°ãƒ©ãƒ•è¡¨ç¤ºã¯ã€Œä»Šæ—¥ã®0æ™‚ã‹ã‚‰24æ™‚ã€ã ãŒã€ãƒ‡ãƒ¼ã‚¿å†…ã§ã®ä½ç½®ã¯ç•°ãªã‚‹
          // displayCurrentTime = å½“æ—¥å†…ã§ã®ç¾åœ¨æ™‚åˆ»ï¼ˆdayOffset ã§æŒ‡å®šã•ã‚ŒãŸæ—¥ã®0æ™‚ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼‰
          // totalHoursSinceReference ã‹ã‚‰ dayOffset * 24 æ™‚é–“ã‚’å·®ã—å¼•ã
          let displayCurrentTime = totalHoursSinceReference - (dayOffset * 24);
          
          const nowUTC = new Date();
          const nowUTCHours = nowUTC.getUTCHours() + nowUTC.getUTCMinutes() / 60;
          const jstCurrentHour = (nowUTCHours + 9) % 24;
          
          console.log('=== Marker calculation ===');
          console.log('referenceTime:', referenceTime, 'nowMs:', nowMs);
          console.log('totalHoursSinceReference:', totalHoursSinceReference, 'dayOffset:', dayOffset);
          console.log('displayCurrentTime (adjusted):', displayCurrentTime);
          console.log('nowUTC:', nowUTC, 'nowUTCHours:', nowUTCHours);
          console.log('jstCurrentHour:', jstCurrentHour);
          
          // ã‚°ãƒ©ãƒ•ã®è¡¨ç¤ºç¯„å›²ï¼ˆ0-24ï¼‰å†…ã«ã‚ã‚‹ã‹ç¢ºèª
          if (displayCurrentTime >= 0 && displayCurrentTime <= 24) {
            const currentX = padding.left + (displayCurrentTime / 24) * chartWidth;
            console.log('Marker X position:', currentX);
            
            // ç¾åœ¨æ™‚åˆ»ã«æœ€ã‚‚è¿‘ã„ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’æ¢ã™
            let currentData = dayData[0];
            let minDiff = Math.abs(dayData[0].hour - displayCurrentTime);
            for (let i = 1; i < dayData.length; i++) {
              const diff = Math.abs(dayData[i].hour - displayCurrentTime);
              if (diff < minDiff) {
                minDiff = diff;
                currentData = dayData[i];
              }
            }
            const normalizedCurrentHeight = (currentData.height - minHeight) / heightRange;
            const currentY = padding.top + chartHeight - (normalizedCurrentHeight * chartHeight);
            console.log('Marker Y position:', currentY, 'height range:', heightRange);
            
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            marker.setAttribute('cx', currentX);
            marker.setAttribute('cy', currentY);
            marker.setAttribute('r', '6');
            marker.setAttribute('fill', '#5ba8d8');
            marker.setAttribute('stroke', '#c4d8f0');
            marker.setAttribute('stroke-width', '2');
            marker.setAttribute('filter', 'drop-shadow(0 0 8px #6bb3e8)');
            svg.appendChild(marker);
            console.log('Marker circle added to SVG');
            
            // ç¾åœ¨æ™‚åˆ»ã®ç¸¦ç·š
            const currentLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            currentLine.setAttribute('x1', currentX);
            currentLine.setAttribute('y1', padding.top);
            currentLine.setAttribute('x2', currentX);
            currentLine.setAttribute('y2', height - padding.bottom);
            currentLine.setAttribute('stroke', '#6bb3e8');
            currentLine.setAttribute('stroke-width', '2');
            currentLine.setAttribute('stroke-dasharray', '4,4');
            currentLine.setAttribute('filter', 'drop-shadow(0 0 5px #a8d8ff)');
            currentLine.setAttribute('stroke-dasharray', '4,4');
            svg.appendChild(currentLine);
            
            // ç¾åœ¨ã®æ½®ä½ã‚’è¡¨ç¤ºï¼ˆå˜ä½ã«å¿œã˜ã¦è¡¨ç¤ºï¼‰
            const currentHeight = isMeters 
              ? (currentData.height * 100).toFixed(0) + ' cm' 
              : Math.round(currentData.height) + ' cm';
            document.getElementById('tideInfo').innerHTML = currentHeight;

            // æº€æ½®/å¹²æ½®ã®çŠ¶æ…‹ã¨æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã¾ã§ã®æ™‚é–“
            // å…¨ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦æ¥µå€¤æ¢ç´¢ã‚’è¡Œã„ã€displayCurrentTimeã¯å…¨7æ—¥ã®ãƒ‡ãƒ¼ã‚¿å†…ã§ã®ç›¸å¯¾æ™‚åˆ»ã«å¤‰æ›
            const fullDataCurrentTime = dayOffset * 24 + displayCurrentTime;
            const trendInfo = getTideTrendAndNextEvent(data, fullDataCurrentTime);
            console.log('Trend info:', trendInfo, 'displayCurrentTime:', displayCurrentTime, 'fullDataCurrentTime:', fullDataCurrentTime, 'data length:', data.length);
            document.getElementById('currentTideStatus').innerHTML = `ç¾åœ¨: ${trendInfo.trend} ${trendInfo.timeToNextEvent}`;
          } else {
            console.log('Current time outside range:', displayCurrentTime);
          }
        }
        
        // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ç”¨ã®è¦ç´ ã‚’è¿½åŠ 
        const tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        tooltip.setAttribute('id', 'tideTooltip');
        tooltip.setAttribute('visibility', 'hidden');
        
        const tooltipBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        tooltipBg.setAttribute('fill', 'rgba(0, 0, 0, 0.8)');
        tooltipBg.setAttribute('rx', '4');
        tooltipBg.setAttribute('ry', '4');
        tooltip.appendChild(tooltipBg);
        
        const tooltipText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tooltipText.setAttribute('fill', 'white');
        tooltipText.setAttribute('font-size', '16');
        tooltipText.setAttribute('font-weight', 'bold');
        tooltipText.setAttribute('text-anchor', 'middle');
        tooltip.appendChild(tooltipText);
        
        svg.appendChild(tooltip);
        
        // ãƒã‚¦ã‚¹ã‚ªãƒ¼ãƒãƒ¼ç”¨ã®é€æ˜ãªçŸ©å½¢
        const interactionRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        interactionRect.setAttribute('x', padding.left);
        interactionRect.setAttribute('y', padding.top);
        interactionRect.setAttribute('width', chartWidth);
        interactionRect.setAttribute('height', chartHeight);
        interactionRect.setAttribute('fill', 'transparent');
        interactionRect.style.cursor = 'crosshair';
        
        interactionRect.addEventListener('mousemove', (e) => {
          const rect = svg.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const relativeX = mouseX - padding.left;
          
          if (relativeX < 0 || relativeX > chartWidth) {
            tooltip.setAttribute('visibility', 'hidden');
            return;
          }
          
          // ãƒã‚¦ã‚¹ä½ç½®ã«åŸºã¥ã„ã¦ç›¸å¯¾æ™‚åˆ»ã‚’è¨ˆç®—ï¼ˆ0-24æ™‚é–“ç¯„å›²ï¼‰
          const relativeHour = (relativeX / chartWidth) * 24;
          
          // æœ€ã‚‚è¿‘ã„ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’è¦‹ã¤ã‘ã¦é«˜ã•ã‚’å–å¾—
          let closestPoint = dayData[0];
          let minDiff = Math.abs(dayData[0].hour - relativeHour);
          for (let i = 1; i < dayData.length; i++) {
            const diff = Math.abs(dayData[i].hour - relativeHour);
            if (diff < minDiff) {
              minDiff = diff;
              closestPoint = dayData[i];
            }
          }
          
          const displayHeight = isMeters 
            ? (closestPoint.height * 100).toFixed(0) + ' cm'
            : closestPoint.height.toFixed(0) + ' cm';
          
          // å®Ÿéš›ã®æ™‚åˆ»ã‚’è¨ˆç®—ï¼ˆå½“æ—¥ã®0æ™‚ã‹ã‚‰ã®çµŒéæ™‚é–“ã¨ã—ã¦ relativeHour ã‚’ä½¿ç”¨ï¼‰
          const actualHour = relativeHour;
          const displayHourPart = Math.floor(actualHour);
          const displayMinPart = Math.round((actualHour % 1) * 60);
          const displayHour = displayHourPart + 'æ™‚' + String(displayMinPart).padStart(2, '0') + 'åˆ†';
          
          tooltipText.textContent = `${displayHour}: ${displayHeight}`;
          
          // ãƒ†ã‚­ã‚¹ãƒˆã®å¹…ã‚’å–å¾—ã—ã¦èƒŒæ™¯ã‚µã‚¤ã‚ºã‚’èª¿æ•´
          const bbox = tooltipText.getBBox();
          tooltipBg.setAttribute('x', bbox.x - 8);
          tooltipBg.setAttribute('y', bbox.y - 4);
          tooltipBg.setAttribute('width', bbox.width + 16);
          tooltipBg.setAttribute('height', bbox.height + 8);
          
          // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ä½ç½®ã‚’è¨­å®š
          const tooltipX = Math.min(Math.max(mouseX, padding.left + 60), width - padding.right - 60);
          const tooltipY = padding.top + 15;
          tooltipText.setAttribute('x', tooltipX);
          tooltipText.setAttribute('y', tooltipY);
          
          tooltip.setAttribute('visibility', 'visible');
        });
        
        interactionRect.addEventListener('mouseleave', () => {
          tooltip.setAttribute('visibility', 'hidden');
        });
        
        svg.appendChild(interactionRect);
        
        // æº€æ½®ãƒ»å¹²æ½®æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆå…ƒãƒ‡ãƒ¼ã‚¿ã®å…¨æœŸé–“ã§æ¤œå‡ºã€æŒ‡å®šæ—¥ã®ã¿è¡¨ç¤ºï¼‰
        const extremes = findTideExtremes(data);
        displayTideExtremes(extremes, referenceHourOfDay || 0, isMeters, dayOffset);
        } catch (err) {
          console.error('drawTideChart error:', err.message, err);
          const svg = document.getElementById('tideChart');
          if (svg) svg.innerHTML = '<text x="300" y="100" text-anchor="middle" fill="#c00">ã‚°ãƒ©ãƒ•ã‚¨ãƒ©ãƒ¼</text>';
        }
      }

      // æ½®ã®æº€ã¡å¼•ãçŠ¶æ…‹ã‚’åˆ¤å®šã¨æ¬¡ã®æº€æ½®ãƒ»å¹²æ½®ã¾ã§ã®æ™‚é–“ã‚’è¨ˆç®—
      function getTideTrendAndNextEvent(data, currentTime) {
        if (!data || data.length < 2) {
          console.log('getTideTrendAndNextEvent: Invalid data');
          return { trend: '---', timeToNextEvent: '' };
        }
        
        console.log('getTideTrendAndNextEvent called with data.length:', data.length, 'currentTime:', currentTime);
        
        // ãƒ‡ãƒ¼ã‚¿ã®æ™‚é–“é–“éš”ã‚’æ¤œå‡ºï¼ˆæœ€åˆã®2ç‚¹ã‹ã‚‰ï¼‰
        const timeInterval = data.length > 1 ? data[1].hour - data[0].hour : 1;
        console.log('Detected timeInterval:', timeInterval);
        
        // currentTime ã¯ 0-24 ã®ç›¸å¯¾æ™‚åˆ»
        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ™‚é–“é–“éš”ã«åŸºã¥ã„ã¦è¨ˆç®—
        const currentIdx = Math.min(Math.floor(currentTime / timeInterval), data.length - 1);
        const nextIdx = Math.min(currentIdx + 1, data.length - 1);
        
        console.log('currentIdx:', currentIdx, 'nextIdx:', nextIdx, 'data[currentIdx]:', data[currentIdx], 'data[nextIdx]:', data[nextIdx]);
        
        if (currentIdx >= data.length) {
          console.log('getTideTrendAndNextEvent: Index out of range');
          return { trend: '---', timeToNextEvent: '' };
        }
        
        const current = data[currentIdx].height;
        const next = data[nextIdx].height;
        
        let trend = '';
        if (next > current) {
          trend = 'ä¸Šã’æ½®ï¼ˆæº€æ½®ã¸ï¼‰ğŸŒŠâ†‘';
        } else if (next < current) {
          trend = 'ä¸‹ã’æ½®ï¼ˆå¹²æ½®ã¸ï¼‰ğŸŒŠâ†“';
        } else {
          trend = 'æ½®ä½ä¸å¤‰';
        }
        
        // æ¬¡ã®æ¥µå€¤ï¼ˆæº€æ½®ã¾ãŸã¯å¹²æ½®ï¼‰ã‚’æ¢ã™
        let nextEventIdx = -1;
        let isMaxima = (next > current); // ç¾åœ¨ä¸Šã’æ½®ãªã‚‰æ¬¡ã¯æº€æ½®ã‚’æ¢ã™
        
        console.log('Looking for next event, isMaxima:', isMaxima, 'starting from index:', currentIdx + 1);
        
        // å½“æ—¥ä¸­ï¼ˆ+24æ™‚é–“ä»¥å†…ï¼‰ã®æ¥µå€¤ã®ã¿ã‚’æ¢ã™
        const dayEndTime = Math.floor(currentTime) + 24; // å½“æ—¥çµ‚äº†æ™‚åˆ»
        const dayEndIdx = Math.ceil(dayEndTime / timeInterval);
        const searchEndIdx = Math.min(dayEndIdx, data.length - 1);
        
        console.log('Searching within day: currentTime=' + currentTime + ', dayEndTime=' + dayEndTime + ', searchEndIdx=' + searchEndIdx + ', dataLength=' + data.length);
        
        if (isMaxima) {
          // æ¥µå¤§å€¤ï¼ˆæº€æ½®ï¼‰ã‚’æ¢ã™
          for (let i = currentIdx + 1; i < searchEndIdx - 1; i++) {
            if (data[i].height > data[i - 1].height && data[i].height > data[i + 1].height) {
              console.log('Found maxima at index', i, 'hour:', data[i].hour, 'height:', data[i].height);
              nextEventIdx = i;
              break;
            }
          }
          if (nextEventIdx === -1) console.log('No maxima found within today');
        } else {
          // æ¥µå°å€¤ï¼ˆå¹²æ½®ï¼‰ã‚’æ¢ã™
          for (let i = currentIdx + 1; i < searchEndIdx - 1; i++) {
            if (data[i].height < data[i - 1].height && data[i].height < data[i + 1].height) {
              console.log('Found minima at index', i, 'hour:', data[i].hour, 'height:', data[i].height);
              nextEventIdx = i;
              break;
            }
          }
          if (nextEventIdx === -1) console.log('No minima found within today');
        }
        
        let timeToNextEvent = '';
        if (nextEventIdx > -1) {
          const nextEventTime = data[nextEventIdx].hour;
          const timeUntilEvent = nextEventTime - currentTime;
          const hours = Math.floor(timeUntilEvent);
          const minutes = Math.round((timeUntilEvent % 1) * 60);
          const eventType = isMaxima ? 'æº€æ½®' : 'å¹²æ½®';
          timeToNextEvent = `${eventType}ã¾ã§${hours}æ™‚é–“${minutes}åˆ†`;
        }
        
        return { trend, timeToNextEvent };
      }

      // æ½®æ±ã®ç°¡æ˜“è¨ˆç®—ï¼ˆå®Ÿéš›ã®APIãŒãªã„å ´åˆã®ãƒ‡ãƒ¢ï¼‰
      function getTideInfo() {
        const hour = new Date().getHours();
        if (hour >= 0 && hour < 6) return 'æº€æ½® â†’ å¹²æ½®';
        else if (hour >= 6 && hour < 12) return 'å¹²æ½®';
        else if (hour >= 12 && hour < 18) return 'å¹²æ½® â†’ æº€æ½®';
        else return 'æº€æ½®';
      }

      // ---- ã‚«ã‚¹ã‚¿ãƒ æ½®æ±API (Cæ¡ˆ) ã®è¨­å®šä¿å­˜/å–å¾— ----
      function getTideConfig() {
        try {
          const raw = localStorage.getItem('tide:config');
          if (!raw) return null;
          return JSON.parse(raw);
        } catch (e) {
          return null;
        }
      }

      function setTideConfig(cfg) {
        try {
          localStorage.setItem('tide:config', JSON.stringify(cfg));
          return true;
        } catch (e) {
          console.warn('setTideConfig failed', e);
          return false;
        }
      }

      // æ±ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰URLã‚’ä½œæˆ
      function buildUrlFromTemplate(template, params) {
        let u = template;
        Object.keys(params).forEach(k => {
          // skip undefined/null
          if (params[k] === undefined || params[k] === null) return;
          u = u.split(`{${k}}`).join(encodeURIComponent(params[k]));
        });

        // If template did not include {key} but a key is provided, append it as query param
        try {
          if (!template.includes('{key}') && params.key) {
            const sep = u.includes('?') ? '&' : '?';
            u = u + `${sep}key=${encodeURIComponent(params.key)}`;
          }
        } catch (e) {
          // ignore
             // 1. ã™ã¹ã¦ã® tide ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç¢ºèª
        console.log('Tide cache keys:', Object.keys(localStorage).filter(k => k.startsWith('tide:')));
        
        // 2. tide:config ä»¥å¤–ã‚’å‰Šé™¤
        Object.keys(localStorage).filter(k => k.startsWith('tide:') && k !== 'tide:config').forEach(k => {
          console.log('Removing:', k);
          localStorage.removeItem(k);
        });
        
        // 3. å‰Šé™¤ç¢ºèª
        console.log('After removal:', Object.keys(localStorage).filter(k => k.startsWith('tide:')));
        
        // 4. ãƒªãƒ­ãƒ¼ãƒ‰
        location.reload();   }

        // WorldTides: å‡ºåŠ›ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
        // ä¾‹: heights, stations, datums ã®ã„ãšã‚Œã‹ãŒå¿…è¦ã€‚
        try {
          if (u.includes('worldtides.info') || u.includes('worldtides.org') ) {
            // simple check for common output params
            const hasOutput = /\b(heights|stations|datums)\b/.test(u);
            if (!hasOutput) {
              const sep2 = u.includes('?') ? '&' : '?';
              u = u + `${sep2}heights`;
            }
          }
        } catch (e) {
          // ignore
        }

        return u;
      }

      // Open-Meteo Marine Weather API ã‚’ä½¿ç”¨ã—ãŸæ½®æ±ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆæ—¥æœ¬æµ·ãƒ»ãã®ä»–åœ°ç‚¹ç”¨ï¼‰
      // World Tides API ã‚’ä½¿ç”¨ã—ãŸæ½®æ±ãƒ‡ãƒ¼ã‚¿å–å¾—
      async function fetchTideWorldTide(lat, lon) {
        try {
          const cacheKey = `tide:marine:v7:${lat},${lon}`;
          const TTL = 3 * 60 * 60; // 3æ™‚é–“

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°è¿”ã™
          const cached = getCacheRecord(cacheKey);
          if (cached) {
            console.log('Returning cached World Tide tide data');
            return cached.value;
          }

          console.log(`Fetching tide data (Open-Meteo Marine) for lat=${lat}, lon=${lon}`);

          // Open-Meteo Marine API: https://marine-api.open-meteo.com/
          const startDate = new Date();
          startDate.setUTCHours(0, 0, 0, 0);
          startDate.setDate(startDate.getDate() - 1); // 1æ—¥å‰ã‚’å«ã‚ã‚‹
          
          const endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 8); // 8æ—¥å¾Œã¾ã§

          const startStr = startDate.toISOString().split('T')[0];
          const endStr = endDate.toISOString().split('T')[0];

          const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=sea_level_height_msl&start_date=${startStr}&end_date=${endStr}&timezone=UTC`;
          console.log('Requesting Open-Meteo Marine API:', url);

          const res = await fetch(url);
          if (!res.ok) {
            let txt = '';
            try { txt = await res.text(); } catch (e) { txt = res.statusText || String(res.status); }
            console.error('Open-Meteo Marine API error', res.status, txt);
            throw new Error('Open-Meteo Marine API error: ' + res.status + ' ' + txt);
          }
          const json = await res.json();
          console.log('Raw Open-Meteo Marine API response:', json);

          if (!json.hourly || !json.hourly.time || !json.hourly.sea_level_height_msl) {
            throw new Error('Invalid Open-Meteo Marine response format');
          }

          const times = json.hourly.time;
          const heights = json.hourly.sea_level_height_msl;
          console.log('Open-Meteo Marine returned', heights.length, 'data points');

          // Open-Meteo Marine ãƒ‡ãƒ¼ã‚¿å¤‰æ›ï¼ˆæ™‚åˆ»ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼‰
          const converted = [];
          const firstTimestamp = new Date(times[0]).getTime(); // æœ€åˆã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆãƒŸãƒªç§’ï¼‰
          
          // å½“æ—¥ã®0æ™‚(JST)ã‚’åŸºæº–ã¨ã—ã¦è¨ˆç®—
          const now = new Date();
          const todayAtMidnightJST = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
          const referenceTime = todayAtMidnightJST.getTime();

          heights.forEach((point, idx) => {
            const hrs = idx; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒæ™‚é–“æ•°
            converted.push({ hour: hrs, height: point });
          });

          console.log(`Converted ${heights.length} points`);
          if (converted.length > 0) {
            console.log('Hour range:', Math.min(...converted.map(d => d.hour)).toFixed(2), 'to', Math.max(...converted.map(d => d.hour)).toFixed(2));
          }

          if (converted.length === 0) throw new Error('Open-Meteo Marine API returned no usable points');

          // ç¾åœ¨æ™‚åˆ»ã‚’è¨ˆç®—ï¼ˆå½“æ—¥ã®0æ™‚ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼‰
          const nowMs = Date.now();
          const currentHour = (nowMs - referenceTime) / (1000 * 60 * 60);

          const normalized = {
            data: converted,
            currentTime: currentHour,
            referenceTime: referenceTime,
            referenceHourOfDay: 0
          };

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
          try { setCache(cacheKey, normalized, TTL); } catch (e) { }

          console.log('Tide data fetched and cached successfully');
          return normalized;
        } catch (err) {
          console.error('fetchTideWorldTide error:', err.message);
          throw err;
        }
      }

      // NOAA Tides & Currents API ã‚’ä½¿ç”¨ã—ãŸæ½®æ±ãƒ‡ãƒ¼ã‚¿å–å¾—
      async function fetchTide(stationIdOrCoords, lon) {
        try {
          const cacheKey = `tide:v7:${stationIdOrCoords}`;
          const TTL = 3 * 60 * 60; // 3æ™‚é–“

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°è¿”ã™
          const cached = getCacheRecord(cacheKey);
          if (cached) {
            console.log('Returning cached tide data');
            return cached.value;
          }

          // stationIdOrCoords ã‹ã‚‰ NOAA ã®è¦³æ¸¬æ‰€ ID ã‚’æŠ½å‡º
          let stationId = stationIdOrCoords;
          if (stationIdOrCoords.includes(',')) {
            // lat,lon ã®å½¢å¼ã®å ´åˆã€æœ€åˆã®ã‚«ãƒ³ãƒã¾ã§ãŒ ID
            stationId = stationIdOrCoords.split(',')[0];
          }

          console.log('Fetching NOAA tide data for station:', stationId);

          // NOAA API: éå»1æ—¥ + å°†æ¥7æ—¥é–“ã‚’å–å¾—
          const nowForRange = new Date();
          const startDate = new Date(nowForRange.getTime() - 24 * 60 * 60 * 1000); // éå»1æ—¥
          const endDate = new Date(nowForRange.getTime() + 7 * 24 * 60 * 60 * 1000); // å°†æ¥7æ—¥é–“

          // NOAA API format: yyyyMMdd HH:mm (UTC)
          const formatNOAADate = (d) => {
            const year = d.getUTCFullYear();
            const month = String(d.getUTCMonth() + 1).padStart(2, '0');
            const day = String(d.getUTCDate()).padStart(2, '0');
            const hours = String(d.getUTCHours()).padStart(2, '0');
            const minutes = String(d.getUTCMinutes()).padStart(2, '0');
            return `${year}${month}${day} ${hours}:${minutes}`;
          };

          const beginDate = formatNOAADate(startDate);
          const endDateStr = formatNOAADate(endDate);

          const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?station=${stationId}&begin_date=${beginDate}&end_date=${endDateStr}&product=predictions&datum=MLLW&units=metric&format=json&time_zone=gmt`;
          console.log('Requesting NOAA API:', url);

          const res = await fetch(url);
          if (!res.ok) {
            let txt = '';
            try { txt = await res.text(); } catch (e) { txt = res.statusText || String(res.status); }
            console.error('NOAA API error', res.status, txt);
            throw new Error('NOAA API error: ' + res.status + ' ' + txt);
          }
          const json = await res.json();
          console.log('Raw NOAA API response:', json);

          // NOAA API response format: { predictions: [{t: "2025-12-07 12:00", v: "1.234"}, ...] }
          if (!json.predictions || !Array.isArray(json.predictions)) {
            throw new Error('Invalid NOAA response format');
          }

          const predictions = json.predictions;
          console.log('NOAA returned', predictions.length, 'predictions');

          // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®è§£æã¨ç›¸å¯¾æ™‚åˆ»ã¸ã®å¤‰æ›
          const converted = [];
          const parsedPoints = [];

          predictions.forEach(p => {
            // NOAA format: "2025-12-07 12:00"
            const timeStr = p.t || '';
            const heightStr = p.v || '0';
            const tms = Date.parse(timeStr);
            
            if (!isNaN(tms)) {
              parsedPoints.push({ time: tms, height: Number(heightStr) });
            }
          });

          if (parsedPoints.length === 0) throw new Error('No valid time points in NOAA response');

          // æœ€åˆã®ãƒã‚¤ãƒ³ãƒˆã®æ™‚åˆ»ã‚’åŸºæº–ï¼ˆhour 0ï¼‰ã¨ã™ã‚‹
          const referenceTime = Math.min(...parsedPoints.map(p => p.time));
          parsedPoints.forEach(p => {
            const hrs = (p.time - referenceTime) / (1000 * 60 * 60);
            converted.push({ hour: hrs, height: p.height });
          });

          console.log(`Normalized ${predictions.length} predictions to ${converted.length} points`);
          if (converted.length > 0) {
            console.log('Hour range:', Math.min(...converted.map(d => d.hour)).toFixed(2), 'to', Math.max(...converted.map(d => d.hour)).toFixed(2));
          }

          if (converted.length === 0) throw new Error('NOAA API returned no usable points');

          converted.sort((a, b) => a.hour - b.hour);

          // ç¾åœ¨æ™‚åˆ»ã‚’è¨ˆç®—ï¼ˆã‚°ãƒ©ãƒ•ã®åŸºæº–æ™‚åˆ» referenceTime ã‹ã‚‰ã®ç›¸å¯¾æ™‚åˆ»ï¼‰
          const nowMs = Date.now();
          const currentHour = (nowMs - referenceTime) / (1000 * 60 * 60);

          // referenceTime ã‚’ Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¦ã€ä»Šæ—¥ã®ä½•æ™‚ã‹ã‚’è¨˜éŒ²ï¼ˆJSTï¼‰
          const refDate = new Date(referenceTime);
          // UTC ã‹ã‚‰ JSTï¼ˆ+9æ™‚é–“ï¼‰ã«å¤‰æ›
          const jstHours = (refDate.getUTCHours() + 9) % 24;
          const referenceHourOfDay = jstHours + refDate.getUTCMinutes() / 60;

          const normalized = {
            data: converted,
            currentTime: currentHour,
            referenceTime: referenceTime,
            referenceHourOfDay: referenceHourOfDay
          };

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
          try { setCache(cacheKey, normalized, TTL); } catch (e) { }

          console.log('Tide data fetched and cached successfully');
          return normalized;
        } catch (err) {
          console.error('fetchTide error:', err.message);
          throw err;
        }
      }

      // åœ°ç‚¹ã®ç¨®é¡ã‚’åˆ¤å®šï¼ˆNOAAè¦³æ¸¬æ‰€ or World Tideåº§æ¨™ï¼‰
      function determineAPIType(stationIdOrCoords) {
        // æ•°å€¤ = NOAA station ID -> åº§æ¨™ã«å¤‰æ›
        if (/^\d+$/.test(stationIdOrCoords)) {
          return 'noaa-id';
        }
        // lat,lon ã®å½¢å¼ã¯ World Tide
        if (stationIdOrCoords.includes(',')) {
          return 'worldtide';
        }
        return 'worldtide'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      }

      // NOAA station ID ã‚’åº§æ¨™ã«å¤‰æ›
      function convertNOAAIDToCoords(stationId) {
        const station = tideStations.find(s => s.value === String(stationId));
        if (station) {
          return { lat: station.lat, lon: station.lon };
        }
        return null;
      }

      // åœ°ç‚¹ã«å¿œã˜ã¦è‡ªå‹•ã§ World Tide ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆNOAA ID ã¯åº§æ¨™ã«å¤‰æ›ï¼‰
      async function fetchTideAuto(stationIdOrCoords, lat, lon) {
        const apiType = determineAPIType(stationIdOrCoords);
        console.log('Determined API type:', apiType, 'for:', stationIdOrCoords);

        let coordsToUse = { lat, lon };

        if (apiType === 'noaa-id') {
          // NOAA ID ã‚’åº§æ¨™ã«å¤‰æ›
          const converted = convertNOAAIDToCoords(stationIdOrCoords);
          if (converted) {
            coordsToUse = converted;
            console.log('Converted NOAA ID', stationIdOrCoords, 'to coords:', coordsToUse);
          } else {
            console.warn('NOAA ID', stationIdOrCoords, 'not found in mapping');
            return generateTideData(); // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          }
        }

        // ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ World Tide ã«çµ±ä¸€
        return fetchTideWorldTide(coordsToUse.lat, coordsToUse.lon);
      }

      // tide ã‚’å–å¾—ã—ã¦æç”»ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ã€‚fetch å¤±æ•—æ™‚ã¯æ—¢å­˜ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‚
      async function updateTideData(stationId, lat, lon) {
        try {
          console.log('updateTideData called. StationId/Coords:', stationId);
          
          const tide = await fetchTideAuto(stationId, lat, lon);
          const maxHour = Math.max(...tide.data.map(d => d.hour));
          console.log('Tide data fetched successfully:', { dataPoints: tide.data.length, hourRange: `${Math.min(...tide.data.map(d => d.hour))} to ${maxHour}` });
          
          // 7æ—¥é–“åˆ†ï¼ˆ168æ™‚é–“ï¼‰ã®ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          if (maxHour < 120) {
            console.warn('API returned insufficient data (< 120 hours). Falling back to simulation.');
            const sim = generateTideData();
            drawTideChart(sim, 0);
            globalTideData = sim;
            initTideTabs();
            return sim;
          }
          
          drawTideChart(tide, 0); // åˆæœŸè¡¨ç¤ºã¯ä»Šæ—¥ï¼ˆdayOffset=0ï¼‰
          globalTideData = tide;
          initTideTabs(); // ã‚¿ãƒ–æ©Ÿèƒ½ã‚’åˆæœŸåŒ–
          return tide;
        } catch (e) {
          console.warn('fetchTide failed, using simulation', e);
          const sim = generateTideData();
          drawTideChart(sim, 0);
          globalTideData = sim;
          initTideTabs();
          return sim;
        }
      }
      
      // ã‚¿ãƒ–æ©Ÿèƒ½ã®åˆæœŸåŒ–
      function generateTabLabel(dayOffset) {
        const baseDate = new Date();
        baseDate.setHours(0, 0, 0, 0);
        const targetDate = new Date(baseDate);
        targetDate.setDate(targetDate.getDate() + dayOffset);
        
        const month = targetDate.getMonth() + 1;
        const day = targetDate.getDate();
        return `${month}/${day}`;
      }
      
      function initTideTabs() {
        const tabsContainer = document.getElementById('tideTabs');
        tabsContainer.innerHTML = ''; // æ—¢å­˜ã®ã‚¿ãƒ–ã‚’ã‚¯ãƒªã‚¢
        
        // 7æ—¥åˆ†ã®ã‚¿ãƒ–ã‚’ç”Ÿæˆ
        for (let i = 0; i < 7; i++) {
          const button = document.createElement('button');
          button.className = 'tide-tab' + (i === 0 ? ' active' : '');
          button.setAttribute('data-day', i);
          button.textContent = generateTabLabel(i);
          button.addEventListener('click', handleTabClick);
          tabsContainer.appendChild(button);
        }
      }
      
      // ã‚¿ãƒ–ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©
      function handleTabClick(e) {
        const tab = e.target;
        const dayOffset = parseInt(tab.getAttribute('data-day'), 10);
        
        console.log('Tab clicked:', dayOffset, 'globalTideData:', globalTideData);
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ãƒ–ã‚’æ›´æ–°
        document.querySelectorAll('.tide-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // ã‚°ãƒ©ãƒ•ã‚’å†æç”»
        if (globalTideData) {
          console.log('Drawing chart for day:', dayOffset, 'data points:', globalTideData.data.length);
          drawTideChart(globalTideData, dayOffset);
        } else {
          console.warn('globalTideData is not available');
        }
      }

      // Open-Meteo APIï¼ˆç„¡æ–™ï¼‰ã§å¤©æ°—æƒ…å ±ã‚’å–å¾—
      async function updateWeatherInfo() {
        const select = document.getElementById('locationSelect');
        const value = select.value; // lat,lon ã®å½¢å¼
        let lat, lon;

        // lat,lon ã®åˆ¤å®š
        if (value.includes(',')) {
          const parts = value.split(',');
          lat = parts[0];
          lon = parts[1];
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæ±äº¬ï¼‰
          lat = '35.6762';
          lon = '139.6503';
        }
        
        // æ½®æ±ã‚°ãƒ©ãƒ•ã‚’å–å¾—ãƒ»æç”»ï¼ˆWorld Tideï¼‰
        const tideData = await updateTideData(value, lat, lon);
        
        try {
          // æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ°—æ¸©ãƒ»é¢¨å‘ããƒ»é¢¨é€Ÿãƒ»æ°—åœ§ãƒ»é›²é‡ãƒ»æ°´æ¸©ï¼‰
          const weatherCacheKey = `weather:${lat},${lon}`;
          const WEATHER_TTL = 10 * 60; // 10åˆ†
          let data = getCache(weatherCacheKey);
          if (!data) {
            const response = await fetch(
              `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,wind_direction_10m,pressure_msl,cloud_cover,sea_surface_temperature&timezone=Asia/Tokyo`
            );
            if (!response.ok) throw new Error('weather API error: ' + response.status);
            data = await response.json();
            try { setCache(weatherCacheKey, data, WEATHER_TTL); } catch (e) { console.warn('failed to cache weather response', e); }
          }
          
          // APIå¿œç­”ã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
          console.log('API Response - current:', data.current);
          
          // æ°—æ¸©
          const temperature = data.current.temperature_2m;
          document.getElementById('tempInfo').innerHTML = temperature ? `${temperature}Â°C` : 'ãƒ‡ãƒ¼ã‚¿ç„¡ã—';
          
          // é¢¨å‘ã
          const windDirection = data.current.wind_direction_10m;
          const windDirectionStr = getWindDirectionStr(windDirection);
          document.getElementById('windDirInfo').innerHTML = windDirectionStr ? `${windDirectionStr}` : 'ãƒ‡ãƒ¼ã‚¿ç„¡ã—';
          
          // æ°´æ¸©ï¼ˆMarine API ã‹ã‚‰å–å¾—ï¼‰
          let waterTemp = null;
          try {
            const marineUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&current=sea_surface_temperature&timezone=Asia/Tokyo`;
            const marineRes = await fetch(marineUrl);
            if (marineRes.ok) {
              const marineData = await marineRes.json();
              waterTemp = marineData.current?.sea_surface_temperature;
              console.log('Marine API æ°´æ¸©ãƒ‡ãƒ¼ã‚¿:', waterTemp);
            }
          } catch (e) {
            console.warn('Marine API æ°´æ¸©å–å¾—ã‚¨ãƒ©ãƒ¼:', e);
          }
          document.getElementById('waterTempInfo').innerHTML = waterTemp !== null && waterTemp !== undefined ? `${waterTemp}Â°C` : 'æ²¿å²¸ãƒ‡ãƒ¼ã‚¿åˆ©ç”¨ä¸å¯';
          
          // é¢¨é€Ÿ
          const windSpeed = data.current.wind_speed_10m;
          document.getElementById('windInfo').innerHTML = `${windSpeed} m/s`;
          
          // æ°—åœ§
          const pressure = data.current.pressure_msl;
          document.getElementById('pressureInfo').innerHTML = pressure ? `${Math.round(pressure)} hPa` : 'ãƒ‡ãƒ¼ã‚¿ç„¡ã—';
          
          // é›²é‡
          const cloudCover = data.current.cloud_cover;
          document.getElementById('cloudCoverInfo').innerHTML = cloudCover !== null ? `${cloudCover}%` : 'ãƒ‡ãƒ¼ã‚¿ç„¡ã—';

          // æ³¢é«˜: marine API ã‚’ä½¿ã£ã¦æœ‰æ„æ³¢é«˜ã¨å‘¨æœŸã‚’å–å¾—ã™ã‚‹ï¼ˆå–å¾—å¤±æ•—æ™‚ã¯é¢¨é€Ÿãƒ™ãƒ¼ã‚¹ã®ç°¡æ˜“æ¨å®šã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          let waveMeters = null;
          let wavePeriod = null;
          try {
            const marine = await fetchMarine(lat, lon);
            if (marine && marine.hourly && Array.isArray(marine.hourly.time) && Array.isArray(marine.hourly.wave_height)) {
              const times = marine.hourly.time; // ISO strings
              const heights = marine.hourly.wave_height;
              
              // ç¾åœ¨æ™‚åˆ»ã«æœ€ã‚‚è¿‘ã„ã€ã‹ã¤ wave_height ãŒ null ã§ãªã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¢ã™
              let idx = -1;
              let bestDiff = Infinity;
              for (let i = 0; i < times.length; i++) {
                if (heights[i] !== null && heights[i] !== undefined) {
                  const t = new Date(times[i]).getTime();
                  const diff = Math.abs(t - Date.now());
                  if (diff < bestDiff) { bestDiff = diff; idx = i; }
                }
              }
              
              if (idx !== -1) {
                waveMeters = parseFloat(heights[idx]);
                if (marine.hourly.wave_period && marine.hourly.wave_period[idx] !== null && marine.hourly.wave_period[idx] !== undefined) {
                  wavePeriod = parseFloat(marine.hourly.wave_period[idx]);
                }
              }
            }
          } catch (e) {
            console.warn('marine API failed, fallback to wind-based estimate', e);
          }

          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: marine ãŒå–ã‚Œãªã„å ´åˆã¯æ—¢å­˜ã®ç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ã‚’æ¡ç”¨
          if (waveMeters == null || Number.isNaN(waveMeters)) {
            waveMeters = parseFloat((windSpeed * 0.3).toFixed(1));
          }

          // UI ã«è¡¨ç¤º
          document.getElementById('waveInfo').innerText = waveMeters != null ? `${waveMeters.toFixed(1)} m${wavePeriod ? ' / ' + Math.round(wavePeriod) + ' s' : ''}` : 'ãƒ‡ãƒ¼ã‚¿ç„¡ã—';
          
          // æœˆé½¢
          document.getElementById('moonInfo').innerHTML = getMoonPhase();
          // é‡£ã‚Šã‚„ã™ã•æŒ‡æ•°ï¼ˆAIè©•ä¾¡ï¼‰ã‚’ç®—å‡º
          try {
            const moonAge = computeMoonAge();
            const trendInfo = getTideTrendAndNextEvent(tideData.data, tideData.currentTime);
            const tideTrend = trendInfo.trend || '';
            const wind = Number(windSpeed) || 0;
            const wave = Number(waveMeters) || 0;

            console.log('AIè©•ä¾¡è¨ˆç®—:', { wind, wave, tideTrend, moonAge });

            let score = 50;
            // é¢¨ãŒå¼·ã„ã»ã©æ¸›ç‚¹ï¼ˆã‚ˆã‚Šç·©å’Œã—ãŸä¿‚æ•°ã«èª¿æ•´ï¼‰
            score -= Math.min(wind, 15) * 2.5; // up to -37.5
            // æ³¢ãŒé«˜ã„ã»ã©æ¸›ç‚¹ï¼ˆã‚ˆã‚Šç·©å’Œã—ãŸä¿‚æ•°ã«èª¿æ•´ï¼‰
            score -= Math.min(wave, 4) * 8; // up to -32
            // æ½®ã®å‹•ãã¯ãƒ—ãƒ©ã‚¹è©•ä¾¡ã«
            if (tideTrend && tideTrend.indexOf('ä¸Šã’æ½®') !== -1) score += 6;
            else if (tideTrend && tideTrend.indexOf('ä¸‹ã’æ½®') !== -1) score -= 2;
            // æœˆé½¢: æ–°æœˆãƒ»æº€æœˆä»˜è¿‘ã¯ã‚„ã‚„ãƒ—ãƒ©ã‚¹
            const fullMoonDist = Math.abs(moonAge - 14.765);
            const newMoonDist = Math.min(Math.abs(moonAge - 0), Math.abs(moonAge - 29.53));
            if (fullMoonDist <= 3 || newMoonDist <= 3) score += 6;

            // æ­£è¦åŒ–
            score = Math.max(0, Math.min(100, Math.round(score)));
            console.log('AIè©•ä¾¡ã‚¹ã‚³ã‚¢:', score);
            let desc = '';
            if (score >= 75) desc = 'éå¸¸ã«è‰¯ã„ â€” é‡£ã‚Šã«é©ã—ã¦ã„ã¾ã™';
            else if (score >= 50) desc = 'è‰¯ã„ â€” æ¡ä»¶ã¯è‰¯å¥½ã§ã™';
            else if (score >= 30) desc = 'æ™®é€š â€” æ³¨æ„ãŒå¿…è¦ã§ã™';
            else desc = 'å³ã—ã„ â€” å®‰å…¨é‡è¦–ã§';

            document.getElementById('aiFishability').innerHTML = `<div class="ai-score"><strong>${score}%</strong><div class="ai-desc">${desc}</div></div>`;
          } catch (e) {
            console.warn('AIè©•ä¾¡ã®ç®—å‡ºã«å¤±æ•—:', e);
            document.getElementById('aiFishability').textContent = 'è¨ˆç®—ã‚¨ãƒ©ãƒ¼';
          }
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ UI ã‚’æ›´æ–°
          try { refreshCacheUI(lat, lon); } catch (e) {}
          
        } catch (error) {
          console.error('å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—:', error);
          document.getElementById('windInfo').innerHTML = 'ã‚¨ãƒ©ãƒ¼';
          document.getElementById('waveInfo').innerHTML = 'ã‚¨ãƒ©ãƒ¼';
          document.getElementById('moonInfo').innerHTML = getMoonPhase();
        }
      }

      // åˆæœŸèª­ã¿è¾¼ã¿ã¨åœ°ç‚¹å¤‰æ›´æ™‚
      document.addEventListener('DOMContentLoaded', () => {
        updateWeatherInfo();
      });
      document.getElementById('locationSelect').addEventListener('change', updateWeatherInfo);
      // ä½ç½®æƒ…å ±ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      document.getElementById('useCurrentLocationBtn').addEventListener('click', useCurrentLocation);
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
      try {
        const btn = document.getElementById('clearCacheBtn');
        if (btn) btn.addEventListener('click', () => { clearCache(); updateWeatherInfo(); });
      } catch (e) {}
    </script>

    <script type="module">
      import { db, auth, configValid, collection, getDocs } from './firebase-init.js';

      // æœ€è¿‘ã®é‡£æœã‚’å–å¾—ã—ã¦è¡¨ç¤º
      async function loadRecentCatches() {
        const container = document.getElementById('recentCatchesList');
        
        if (!configValid || !db) {
          container.innerHTML = '<p style="text-align: center; color: #666;">Firebaseæœªè¨­å®šã®ãŸã‚è¡¨ç¤ºã§ãã¾ã›ã‚“</p>';
          return;
        }

        try {
          console.log('é‡£æœãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...');
          
          // å…¨ä»¶å–å¾—ã—ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã‚½ãƒ¼ãƒˆï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸è¦ï¼‰
          const querySnapshot = await getDocs(collection(db, 'fishinglogs'));
          
          console.log(`å–å¾—ä»¶æ•°: ${querySnapshot.size}`);
          
          if (querySnapshot.empty) {
            container.innerHTML = '<p style="text-align: center; color: #666;">ã¾ã é‡£æœãŒã‚ã‚Šã¾ã›ã‚“</p>';
            return;
          }

          // ãƒ‡ãƒ¼ã‚¿ã‚’é…åˆ—ã«å¤‰æ›ã—ã¦æ—¥ä»˜ã§ã‚½ãƒ¼ãƒˆ
          const catches = [];
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.catch) {
              catches.push({ id: doc.id, ...data });
            }
          });
          
          // æ—¥ä»˜ã®é™é †ã§ã‚½ãƒ¼ãƒˆ
          catches.sort((a, b) => {
            const dateA = a.catch.date || '';
            const dateB = b.catch.date || '';
            return dateB.localeCompare(dateA);
          });
          
          // æœ€æ–°5ä»¶ã®ã¿è¡¨ç¤º
          const recentCatches = catches.slice(0, 5);
          
          if (recentCatches.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #666;">ã¾ã é‡£æœãŒã‚ã‚Šã¾ã›ã‚“</p>';
            return;
          }

          let html = '';
          recentCatches.forEach((item) => {
            const catchData = item.catch || {};
            const imageUrl = catchData.imageUrl || '';
            const fish = catchData.fish || 'ä¸æ˜';
            const date = catchData.date || '';
            const size = catchData.size || '-';
            const location = catchData.location || '';
            
            html += `
              <div class="recent-catch-item" style="display: grid; grid-template-columns: 80px 1fr; gap: 12px; align-items: center; min-height: 80px; padding: 8px; cursor: pointer; transition: background-color 0.2s;" onclick="window.location.href='fishing-log2-detail.html?id=${item.id}'" onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='transparent'">
                <div class="catch-thumbnail" style="width: 80px; height: 80px; overflow: hidden; border-radius: 4px;">
                  ${imageUrl ? `<img src="${imageUrl}" alt="${fish}" loading="lazy" style="width: 100%; height: 100%; object-fit: cover; display: block;" onerror="this.style.display='none'; this.parentElement.querySelector('.no-thumb-fallback').style.display='flex'">` : ``}
                  <div class="no-thumb-fallback" style="display: ${imageUrl ? 'none' : 'flex'}; align-items: center; justify-content: center; height: 100%; font-size: 2rem; opacity: 0.4;">
                    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 7H5.17L6.59 4.59C6.86 4.21 7.3 4 7.77 4H16.23C16.7 4 17.14 4.21 17.41 4.59L18.83 7H20C21.1 7 22 7.9 22 9V19C22 20.1 21.1 21 20 21H4C2.9 21 2 20.1 2 19V9C2 7.9 2.9 7 4 7Z" fill="#90caf9"/></svg>
                  </div>
                </div>
<div class="catch-info-inline" style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                  <span class="catch-fish" style="font-weight: bold; color: #0277bd; font-size: 1.1rem;">${fish}</span>
                  <span class="catch-meta" style="color: #666; font-size: 0.9rem; display: inline-flex; align-items: center; gap:6px;">
                    <svg class="icon-sm" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M7 10H17V7H7V10Z" fill="#666"/><path d="M19 4H18V2H16V4H8V2H6V4H5C3.9 4 3 4.9 3 6V20C3 21.1 3.9 22 5 22H19C20.1 22 21 21.1 21 20V6C21 4.9 20.1 4 19 4Z" fill="#ccc" opacity="0.6"/></svg>
                    ${date}
                  </span>
                  <span class="catch-meta" style="color: #666; font-size: 0.9rem; display: inline-flex; align-items: center; gap:6px;">
                    <svg class="icon-sm" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 3H5V5H3V3ZM7 3H9V5H7V3ZM11 3H13V5H11V3ZM15 3H17V5H15V3Z" fill="#666"/><path d="M5 7H19V21H5V7Z" stroke="#666" stroke-width="0" fill="#e0e0e0"/></svg>
                    ${size}cm
                  </span>
                  <span class="catch-meta" style="color: #666; font-size: 0.9rem; display: inline-flex; align-items: center; gap:6px;">
                    <svg class="icon-sm" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 2C8.13 2 5 5.13 5 9C5 14.25 12 22 12 22C12 22 19 14.25 19 9C19 5.13 15.87 2 12 2ZM12 11.5C10.62 11.5 9.5 10.38 9.5 9C9.5 7.62 10.62 6.5 12 6.5C13.38 6.5 14.5 7.62 14.5 9C14.5 10.38 13.38 11.5 12 11.5Z" fill="#666"/></svg>
                    ${location}
                  </span>
                </div>
              </div>
            `;
          });
          
          console.log('ç”Ÿæˆã•ã‚ŒãŸHTML:', html.substring(0, 200));
          container.innerHTML = html;
          console.log('é‡£æœãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºå®Œäº†ã€‚è¡¨ç¤ºä»¶æ•°:', recentCatches.length);
          
        } catch (error) {
          console.error('é‡£æœã®å–å¾—ã«å¤±æ•—:', error);
          console.error('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error.stack);
          container.innerHTML = `<p style="text-align: center; color: #e74c3c;">é‡£æœã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}</p>`;
        }
      }

      // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«å®Ÿè¡Œ
      document.addEventListener('DOMContentLoaded', loadRecentCatches);
    </script>
  </body>
</html>
